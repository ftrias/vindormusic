/*!
 *  @file		packet-rtp-midi.h
 *  Project		Arduino AppleMIDI Library
 *	@brief		AppleMIDI Library for the Arduino
 *	Version		0.0
 *  @author		lathoub, hackmancoltaire
 *	@date		01/04/13
 *  License		Code is open source so please feel free to do anything you want with it; you buy me a beer if you use this and we meet someday (Beerware license).
 */

#pragma once

#include "AppleMidi_Settings.h"

#include "packet-rtp.h"

BEGIN_APPLEMIDI_NAMESPACE

/* Definitions for protocol name during dissector-register */
#define RTP_MIDI_DISSECTOR_NAME "RFC 4695/6295 RTP-MIDI"
#define RTP_MIDI_DISSECTOR_SHORTNAME "RTP-MIDI"
#define RTP_MIDI_DISSECTOR_ABBREVIATION "rtpmidi"

#define RTP_MIDI_NO_RUNNING_STATUS 0xffff

/*
* MIDI Controller Numbers
*/
#define RTP_MIDI_CTRL_BANK_SELECT_MSB 0
#define RTP_MIDI_CTRL_MODULATION_WHEEL_OR_LEVER_MSB 1
#define RTP_MIDI_CTRL_BREATH_CONTROLLER_MSB 2
/* #define RTP_MIDI_CTRL 3 */
#define RTP_MIDI_CTRL_FOOT_CONTROLLER_MSB 4
#define RTP_MIDI_CTRL_PORTAMENTO_TIME_MSB 5
#define RTP_MIDI_CTRL_DATA_ENTRY_MSB 6
#define RTP_MIDI_CTRL_CHANNEL_VOLUME_MSB 7
#define RTP_MIDI_CTRL_BALANCE_MSB 8
/* #define RTP_MIDI_CTRL 9 */
#define RTP_MIDI_CTRL_PAN_MSB 10
#define RTP_MIDI_CTRL_EXPRESSION_CONTROLLER_MSB 11
#define RTP_MIDI_CTRL_EFFECT_CONTROL_1_MSB 12
#define RTP_MIDI_CTRL_EFFECT_CONTROL_2_MSB 13
/* #define RTP_MIDI_CTRL_ 14
#define RTP_MIDI_CTRL_ 15 */
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_1_MSB 16
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_2_MSB 17
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_3_MSB 18
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_4_MSB 19
/* #define RTP_MIDI_CTRL_ 20
#define RTP_MIDI_CTRL_ 21
#define RTP_MIDI_CTRL_ 22
#define RTP_MIDI_CTRL_ 23
#define RTP_MIDI_CTRL_ 24
#define RTP_MIDI_CTRL_ 25
#define RTP_MIDI_CTRL_ 26
#define RTP_MIDI_CTRL_ 27
#define RTP_MIDI_CTRL_ 28
#define RTP_MIDI_CTRL_ 29
#define RTP_MIDI_CTRL_ 30
#define RTP_MIDI_CTRL_ 31 */
#define RTP_MIDI_CTRL_BANK_SELECT_LSB 32
#define RTP_MIDI_CTRL_MODULATION_WHEEL_OR_LEVER_LSB 33
#define RTP_MIDI_CTRL_BREATH_CONTROLLER_LSB 34
/* #define RTP_MIDI_CTRL_ 35 */
#define RTP_MIDI_CTRL_FOOT_CONTROLLER_LSB 36
#define RTP_MIDI_CTRL_PORTAMENTO_TIME_LSB 37
#define RTP_MIDI_CTRL_DATA_ENTRY_LSB 38
#define RTP_MIDI_CTRL_CHANNEL_VOLUME_LSB 39
#define RTP_MIDI_CTRL_BALANCE_LSB 40
/* #define RTP_MIDI_CTRL_ 41 */
#define RTP_MIDI_CTRL_PAN_LSB 42
#define RTP_MIDI_CTRL_EXPRESSION_CONTROLLER_LSB 43
#define RTP_MIDI_CTRL_EFFECT_CONTROL_1_LSB 44
#define RTP_MIDI_CTRL_EFFECT_CONTROL_2_LSB 45
/* #define RTP_MIDI_CTRL_ 46
#define RTP_MIDI_CTRL_ 47 */
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_1_LSB 48
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_2_LSB 49
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_3_LSB 50
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_4_LSB 51
/* #define RTP_MIDI_CTRL_ 52
#define RTP_MIDI_CTRL_ 53
#define RTP_MIDI_CTRL_ 54
#define RTP_MIDI_CTRL_ 55
#define RTP_MIDI_CTRL_ 56
#define RTP_MIDI_CTRL_ 57
#define RTP_MIDI_CTRL_ 58
#define RTP_MIDI_CTRL_ 59
#define RTP_MIDI_CTRL_ 60
#define RTP_MIDI_CTRL_ 61
#define RTP_MIDI_CTRL_ 62
#define RTP_MIDI_CTRL_ 63 */
#define RTP_MIDI_CTRL_DAMPER_PEDAL 64
#define RTP_MIDI_CTRL_PORTAMENTO_ON_OFF 65
#define RTP_MIDI_CTRL_SUSTENUTO 66
#define RTP_MIDI_CTRL_SOFT_PEDAL 67
#define RTP_MIDI_CTRL_LEGATO_FOOTSWITCH 68
#define RTP_MIDI_CTRL_HOLD_2 69
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_1 70
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_2 71
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_3 72
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_4 73
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_5 74
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_6 75
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_7 76
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_8 77
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_9 78
#define RTP_MIDI_CTRL_SOUND_CONTROLLER_10 79
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_5 80
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_6 81
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_7 82
#define RTP_MIDI_CTRL_GENERAL_PURPOSE_CONTROLLER_8 83
#define RTP_MIDI_CTRL_PORTAMENTO_CONTROL 84
/* #define RTP_MIDI_CTRL_ 85
#define RTP_MIDI_CTRL_ 86
#define RTP_MIDI_CTRL_ 87
#define RTP_MIDI_CTRL_ 88
#define RTP_MIDI_CTRL_ 89
#define RTP_MIDI_CTRL_ 90 */
#define RTP_MIDI_CTRL_EFFECTS_1_DEPTH 91
#define RTP_MIDI_CTRL_EFFECTS_2_DEPTH 92
#define RTP_MIDI_CTRL_EFFECTS_3_DEPTH 93
#define RTP_MIDI_CTRL_EFFECTS_4_DEPTH 94
#define RTP_MIDI_CTRL_EFFECTS_5_DEPTH 95
#define RTP_MIDI_CTRL_DATA_INCREMENT 96
#define RTP_MIDI_CTRL_DATA_DECREMENT 97
#define RTP_MIDI_CTRL_NON_REGISTERED_PARAM_LSB 98
#define RTP_MIDI_CTRL_NON_REGISTERED_PARAM_MSB 99
#define RTP_MIDI_CTRL_REGISTERED_PARAM_LSB 100
#define RTP_MIDI_CTRL_REGISTERED_PARAM_MSB 101
/* #define RTP_MIDI_CTRL_ 102
#define RTP_MIDI_CTRL_ 103
#define RTP_MIDI_CTRL_ 104
#define RTP_MIDI_CTRL_ 105
#define RTP_MIDI_CTRL_ 106
#define RTP_MIDI_CTRL_ 107
#define RTP_MIDI_CTRL_ 108
#define RTP_MIDI_CTRL_ 109
#define RTP_MIDI_CTRL_ 110
#define RTP_MIDI_CTRL_ 111
#define RTP_MIDI_CTRL_ 112
#define RTP_MIDI_CTRL_ 113
#define RTP_MIDI_CTRL_ 114
#define RTP_MIDI_CTRL_ 115
#define RTP_MIDI_CTRL_ 116
#define RTP_MIDI_CTRL_ 117
#define RTP_MIDI_CTRL_ 118
#define RTP_MIDI_CTRL_ 119 */
/* MIDI Channel Mode Messages */
#define RTP_MIDI_CTRL_ALL_SOUND_OFF 120
#define RTP_MIDI_CTRL_RESET_ALL_CONTROLLERS 121
#define RTP_MIDI_CTRL_LOCAL_CONTROL_ON_OFF 122
#define RTP_MIDI_CTRL_ALL_NOTES_OFF 123
#define RTP_MIDI_CTRL_OMNI_MODE_OFF 124
#define RTP_MIDI_CTRL_OMNI_MODE_ON 125
#define RTP_MIDI_CTRL_MONO_MODE_ON 126
#define RTP_MIDI_CTRL_POLY_MODE_ON 127


/*
* MIDI Status Bytes (Channel Voice Messages)
*/
#define RTP_MIDI_STATUS_CHANNEL_NOTE_OFF 0x08 /* 0x8n n->channel */
#define RTP_MIDI_STATUS_CHANNEL_NOTE_ON 0x09 /* 0x9n n->channel */
#define RTP_MIDI_STATUS_CHANNEL_POLYPHONIC_KEY_PRESSURE 0x0a /* 0xan n->channel */
#define RTP_MIDI_STATUS_CHANNEL_CONTROL_CHANGE 0x0b /* 0xbn n->channel */
#define RTP_MIDI_STATUS_CHANNEL_PROGRAM_CHANGE 0x0c /* 0xcn n->channel */
#define RTP_MIDI_STATUS_CHANNEL_CHANNEL_PRESSURE 0x0d /* 0xdn n->channel */
#define RTP_MIDI_STATUS_CHANNEL_PITCH_BEND_CHANGE 0x0e /* 0xen n->channel */

/*
* MIDI-Channels
*/
#define RTP_MIDI_CHANNEL_1 0x00
#define RTP_MIDI_CHANNEL_2 0x01
#define RTP_MIDI_CHANNEL_3 0x02
#define RTP_MIDI_CHANNEL_4 0x03
#define RTP_MIDI_CHANNEL_5 0x04
#define RTP_MIDI_CHANNEL_6 0x05
#define RTP_MIDI_CHANNEL_7 0x06
#define RTP_MIDI_CHANNEL_8 0x07
#define RTP_MIDI_CHANNEL_9 0x08
#define RTP_MIDI_CHANNEL_10 0x09
#define RTP_MIDI_CHANNEL_11 0x0a
#define RTP_MIDI_CHANNEL_12 0x0b
#define RTP_MIDI_CHANNEL_13 0x0c
#define RTP_MIDI_CHANNEL_14 0x0d
#define RTP_MIDI_CHANNEL_15 0x0e
#define RTP_MIDI_CHANNEL_16 0x0f
#define RTP_MIDI_CHANNEL_MASK 0x0f


/*
* MIDI Status Bytes (System Exclusive Messages, System Common Messages, System Realtime Messages )
*/
#define RTP_MIDI_STATUS_COMMON_SYSEX_START 0xf0
#define RTP_MIDI_STATUS_COMMON_MTC_QUARTER_FRAME 0xf1
#define RTP_MIDI_STATUS_COMMON_SONG_POSITION_POINTER 0xf2
#define RTP_MIDI_STATUS_COMMON_SONG_SELECT 0xf3
#define RTP_MIDI_STATUS_COMMON_UNDEFINED_F4 0xf4
#define RTP_MIDI_STATUS_COMMON_UNDEFINED_F5 0xf5
#define RTP_MIDI_STATUS_COMMON_TUNE_REQUEST 0xf6
#define RTP_MIDI_STATUS_COMMON_SYSEX_END 0xf7
#define RTP_MIDI_STATUS_COMMON_REALTIME_TIMING_CLOCK 0xf8
#define RTP_MIDI_STATUS_COMMON_REALTIME_MIDI_TICK 0xf9 /* Spec says undefined */
#define RTP_MIDI_STATUS_COMMON_REALTIME_START 0xfa
#define RTP_MIDI_STATUS_COMMON_REALTIME_CONTINUE 0xfb
#define RTP_MIDI_STATUS_COMMON_REALTIME_STOP 0xfc
#define RTP_MIDI_STATUS_COMMON_REALTIME_UNDEFINED_FD 0xfd
#define RTP_MIDI_STATUS_COMMON_REALTIME_ACTIVE_SENSING 0xfe
#define RTP_MIDI_STATUS_COMMON_REALTIME_SYSTEM_RESET 0xff


/*
* MIDI Universal Non-Realtime System Exclusive Messages (sysex-manu-id=0x7e)
*/
#define RTP_MIDI_SYSEX_COMMON_NRT_SAMPLE_DUMP_HEADER 0x01
#define RTP_MIDI_SYSEX_COMMON_NRT_SAMPLE_DATA_PACKET 0x02
#define RTP_MIDI_SYSEX_COMMON_NRT_SAMPLE_DUMP_REQUEST 0x03
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC 0x04
#define RTP_MIDI_SYSEX_COMMON_NRT_SAMPLE_DUMP_EXTENSIONS 0x05
#define RTP_MIDI_SYSEX_COMMON_NRT_GENERAL_INFORMATION 0x06
#define RTP_MIDI_SYSEX_COMMON_NRT_FILE_DUMP 0x07
#define RTP_MIDI_SYSEX_COMMON_NRT_MIDI_TUNING_STANDARD 0x08
#define RTP_MIDI_SYSEX_COMMON_NRT_GENERAL_MIDI 0x09
#define RTP_MIDI_SYSEX_COMMON_NRT_DOWNLOADABLE_SOUNDS 0x0a
#define RTP_MIDI_SYSEX_COMMON_NRT_END_OF_FILE 0x7b
#define RTP_MIDI_SYSEX_COMMON_NRT_WAIT 0x7c
#define RTP_MIDI_SYSEX_COMMON_NRT_CANCEL 0x7d
#define RTP_MIDI_SYSEX_COMMON_NRT_NAK 0x7e
#define RTP_MIDI_SYSEX_COMMON_NRT_ACK 0x7f


/*
* MIDI Universal Realtime System Exclusive Messages (sysex-manu-id=0x7f)
*/
#define RTP_MIDI_SYSEX_COMMON_RT_MIDI_TIME_CODE 0x01
#define RTP_MIDI_SYSEX_COMMON_RT_MIDI_SHOW_CONTROL 0x02
#define RTP_MIDI_SYSEX_COMMON_RT_NOTATION_INFORMATION 0x03
#define RTP_MIDI_SYSEX_COMMON_RT_DEVICE_CONTROL 0x04
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUEING 0x05
#define RTP_MIDI_SYSEX_COMMON_RT_MIDI_MACHINE_CONTROL_COMMAND 0x06
#define RTP_MIDI_SYSEX_COMMON_RT_MIDI_MACHINE_CONTROL_RESPONSE 0x07
#define RTP_MIDI_SYSEX_COMMON_RT_MIDI_TUNING_STANDARD 0x08


/* List of short MIDI-manufacturer-IDs - needs to be completed! */
#define RTP_MIDI_MANU_SHORT_ISLONG 0x00
#define RTP_MIDI_MANU_SHORT_SEQUENTIAL_CIRCUITS 0x01
#define RTP_MIDI_MANU_SHORT_BIG_BRIAR_IDP 0x02
#define RTP_MIDI_MANU_SHORT_OCTAVE_PLATEAU_VOYETRA 0x03
#define RTP_MIDI_MANU_SHORT_MOOG 0x04
#define RTP_MIDI_MANU_SHORT_PASSPORT_DESIGNS 0x05
#define RTP_MIDI_MANU_SHORT_LEXICON 0x06
#define RTP_MIDI_MANU_SHORT_KURZWEIL 0x07
#define RTP_MIDI_MANU_SHORT_FENDER 0x08
#define RTP_MIDI_MANU_SHORT_GULBRANSEN 0x09
#define RTP_MIDI_MANU_SHORT_AKG_ACOUSTICS 0x0a
#define RTP_MIDI_MANU_SHORT_VOYCE_MUSIC 0x0b
#define RTP_MIDI_MANU_SHORT_WAVEFRAME 0x0c
#define RTP_MIDI_MANU_SHORT_ADA_SIGNAL_PROCESSORS 0x0d
#define RTP_MIDI_MANU_SHORT_GARFIELD_ELECTRONICS 0x0e
#define RTP_MIDI_MANU_SHORT_ENSONIQ 0x0f
#define RTP_MIDI_MANU_SHORT_OBERHEIM_GIBSON_LABS 0x10
#define RTP_MIDI_MANU_SHORT_APPLE_COMPUTERS 0x11
#define RTP_MIDI_MANU_SHORT_GREY_MATTER_RESPONSE 0x12
#define RTP_MIDI_MANU_SHORT_DIGIDESIGN 0x13
#define RTP_MIDI_MANU_SHORT_PALMTREE_INSTRUMENTS 0x14
#define RTP_MIDI_MANU_SHORT_JL_COOPER 0x15
#define RTP_MIDI_MANU_SHORT_LOWREY 0x16
#define RTP_MIDI_MANU_SHORT_LINN_ADAMS_SMITH 0x17
#define RTP_MIDI_MANU_SHORT_EMU_SYSTEMS 0x18
#define RTP_MIDI_MANU_SHORT_HARMONY_SYSTEMS 0x19
#define RTP_MIDI_MANU_SHORT_ART 0x1a
#define RTP_MIDI_MANU_SHORT_BALDWIN 0x1b
#define RTP_MIDI_MANU_SHORT_EVENTIDE 0x1c
#define RTP_MIDI_MANU_SHORT_INVENTRONICS 0x1d
#define RTP_MIDI_MANU_SHORT_KEY_CONCEPTS 0x1e
#define RTP_MIDI_MANU_SHORT_CLARITY 0x1f
#define RTP_MIDI_MANU_SHORT_PASSAC 0x20
#define RTP_MIDI_MANU_SHORT_SIEL 0x21
#define RTP_MIDI_MANU_SHORT_SYNTHE_AXE 0x22
#define RTP_MIDI_MANU_SHORT_STEPP 0x23
#define RTP_MIDI_MANU_SHORT_HOHNER 0x24
#define RTP_MIDI_MANU_SHORT_CRUMAR_TWISTER 0x25
#define RTP_MIDI_MANU_SHORT_SOLTON 0x26
#define RTP_MIDI_MANU_SHORT_JELLINGHAUS_MS 0x27
#define RTP_MIDI_MANU_SHORT_SOUTHWORK_MUSIC_SYSTEMS 0x28
#define RTP_MIDI_MANU_SHORT_PPG 0x29
#define RTP_MIDI_MANU_SHORT_JEN 0x2a
#define RTP_MIDI_MANU_SHORT_SSL 0x2b
#define RTP_MIDI_MANU_SHORT_AUDIO_VERITRIEB 0x2c
#define RTP_MIDI_MANU_SHORT_NEVE_HINTON_INSTRUMENTS 0x2d
#define RTP_MIDI_MANU_SHORT_SOUNDTRACS 0x2e
#define RTP_MIDI_MANU_SHORT_ELKA_GENERAL_MUSIC 0x2f
#define RTP_MIDI_MANU_SHORT_DYNACORD 0x30
#define RTP_MIDI_MANU_SHORT_VISCOUNT 0x31
#define RTP_MIDI_MANU_SHORT_DRAWMER 0x32
#define RTP_MIDI_MANU_SHORT_CLAVIA_DIGITAL_INSTRUMENTS 0x33
#define RTP_MIDI_MANU_SHORT_AUDIO_ARCHITECTURE 0x34
#define RTP_MIDI_MANU_SHORT_GENERAL_MUSIC_CORP 0x35
#define RTP_MIDI_MANU_SHORT_CHEETAH 0x36
#define RTP_MIDI_MANU_SHORT_CTM 0x37
#define RTP_MIDI_MANU_SHORT_SIMMONS_UK 0x38
#define RTP_MIDI_MANU_SHORT_SOUNDCRAFT_ELECTRONICS 0x39
#define RTP_MIDI_MANU_SHORT_STEINBERG_GMBH 0x3a
#define RTP_MIDI_MANU_SHORT_WERSI 0x3b
#define RTP_MIDI_MANU_SHORT_AVAB_ELEKTRONIK_AB 0x3c
#define RTP_MIDI_MANU_SHORT_DIGIGRAM 0x3d
#define RTP_MIDI_MANU_SHORT_WALDORF 0x3e
#define RTP_MIDI_MANU_SHORT_QUASIMIDI 0x3f
#define RTP_MIDI_MANU_SHORT_KAWAI 0x40
#define RTP_MIDI_MANU_SHORT_ROLAND 0x41
#define RTP_MIDI_MANU_SHORT_KORG 0x42
#define RTP_MIDI_MANU_SHORT_YAMAHA 0x43
#define RTP_MIDI_MANU_SHORT_CASIO 0x44
#define RTP_MIDI_MANU_SHORT_MORIDAIRA 0x45
#define RTP_MIDI_MANU_SHORT_KAMIYA_STUDIO 0x46
#define RTP_MIDI_MANU_SHORT_AKAI 0x47
#define RTP_MIDI_MANU_SHORT_JAPAN_VICTOR 0x48
#define RTP_MIDI_MANU_SHORT_MEISOSHA 0x49
#define RTP_MIDI_MANU_SHORT_HOSHINO_GAKKI 0x4a
#define RTP_MIDI_MANU_SHORT_FUJITSU 0x4b
#define RTP_MIDI_MANU_SHORT_SONY 0x4c
#define RTP_MIDI_MANU_SHORT_NISSHIN_ONPA 0x4d
#define RTP_MIDI_MANU_SHORT_TEAC 0x4e
/* #define RTP_MIDI_MANU_SHORT_ 0x4f */
#define RTP_MIDI_MANU_SHORT_MATSUSHITA_ELECTRIC 0x50
#define RTP_MIDI_MANU_SHORT_FOSTEX 0x51
#define RTP_MIDI_MANU_SHORT_ZOOM 0x52
#define RTP_MIDI_MANU_SHORT_MIDORI_ELECTRONICS 0x53
#define RTP_MIDI_MANU_SHORT_MATSUSHITA_COMMUNICATION 0x54
#define RTP_MIDI_MANU_SHORT_SUZUKI 0x55
#define RTP_MIDI_MANU_SHORT_FUJI 0x56
#define RTP_MIDI_MANU_SHORT_ACOUSTIC_TECHNICAL_LAB 0x57
/* #define RTP_MIDI_MANU_SHORT_ 0x58 */
#define RTP_MIDI_MANU_SHORT_FAITH 0x59
#define RTP_MIDI_MANU_SHORT_INTERNET_CORPORATION 0x5a
/* #define RTP_MIDI_MANU_SHORT_ 0x5b */
#define RTP_MIDI_MANU_SHORT_SEEKERS_CO 0x5c
/* #define RTP_MIDI_MANU_SHORT_ 0x5d */
/* #define RTP_MIDI_MANU_SHORT_ 0x5e */
#define RTP_MIDI_MANU_SHORT_SD_CARD_ASSOCIATION 0x5f
/* #define RTP_MIDI_MANU_SHORT_ 0x60
#define RTP_MIDI_MANU_SHORT_ 0x61
#define RTP_MIDI_MANU_SHORT_ 0x62
#define RTP_MIDI_MANU_SHORT_ 0x63
#define RTP_MIDI_MANU_SHORT_ 0x64
#define RTP_MIDI_MANU_SHORT_ 0x65
#define RTP_MIDI_MANU_SHORT_ 0x66
#define RTP_MIDI_MANU_SHORT_ 0x67
#define RTP_MIDI_MANU_SHORT_ 0x68
#define RTP_MIDI_MANU_SHORT_ 0x69
#define RTP_MIDI_MANU_SHORT_ 0x6a
#define RTP_MIDI_MANU_SHORT_ 0x6b
#define RTP_MIDI_MANU_SHORT_ 0x6c
#define RTP_MIDI_MANU_SHORT_ 0x6d
#define RTP_MIDI_MANU_SHORT_ 0x6e
#define RTP_MIDI_MANU_SHORT_ 0x6f
#define RTP_MIDI_MANU_SHORT_ 0x70
#define RTP_MIDI_MANU_SHORT_ 0x71
#define RTP_MIDI_MANU_SHORT_ 0x72
#define RTP_MIDI_MANU_SHORT_ 0x73
#define RTP_MIDI_MANU_SHORT_ 0x74
#define RTP_MIDI_MANU_SHORT_ 0x75
#define RTP_MIDI_MANU_SHORT_ 0x76
#define RTP_MIDI_MANU_SHORT_ 0x77
#define RTP_MIDI_MANU_SHORT_ 0x78
#define RTP_MIDI_MANU_SHORT_ 0x79
#define RTP_MIDI_MANU_SHORT_ 0x7a
#define RTP_MIDI_MANU_SHORT_ 0x7b
#define RTP_MIDI_MANU_SHORT_ 0x7c */
#define RTP_MIDI_MANU_SHORT_EDUCATIONAL_USE 0x7d
#define RTP_MIDI_MANU_SHORT_NON_REALTIME_UNIVERSAL 0x7e
#define RTP_MIDI_MANU_SHORT_REALTIME_UNIVERSAL 0x7f


/* List of long MIDI-manufacturer-IDs - needs to be completed! */
/* North American Manufacturers */
/* #define RTP_MIDI_MANU_LONG_TIME_ 0x0000 */
#define RTP_MIDI_MANU_LONG_TIME_WARNER_INTERACTIVE 0x0001
#define RTP_MIDI_MANU_LONG_ADVANCED_GRAVIS_COMP 0x0002
#define RTP_MIDI_MANU_LONG_MEDIA_VISION 0x0003
#define RTP_MIDI_MANU_LONG_DORNES_RESEARCH_GROUP 0x0004
#define RTP_MIDI_MANU_LONG_KMUSE 0x0005
#define RTP_MIDI_MANU_LONG_STYPHER 0x0006
#define RTP_MIDI_MANU_LONG_DIGITAL_MUSIC_CORPORATION 0x0007
#define RTP_MIDI_MANU_LONG_IOTA_SYSTEMS 0x0008
#define RTP_MIDI_MANU_LONG_NEW_ENGLAND_DIGITAL 0x0009
#define RTP_MIDI_MANU_LONG_ARTISYN 0x000a
#define RTP_MIDI_MANU_LONG_IVL_TECHNOLOGIES 0x000b
#define RTP_MIDI_MANU_LONG_SOUTHERN_MUSIC_SYSTEMS 0x000c
#define RTP_MIDI_MANU_LONG_LAKE_BUTLER_SOUND_COMPANY 0x000d
#define RTP_MIDI_MANU_LONG_ALESIS 0x000e
#define RTP_MIDI_MANU_LONG_SOUND_CREATION 0x000f
#define RTP_MIDI_MANU_LONG_DOD_ELECTRONICS 0x0010
#define RTP_MIDI_MANU_LONG_STUDER_EDITECH 0x0011
#define RTP_MIDI_MANU_LONG_SONUS 0x0012
#define RTP_MIDI_MANU_LONG_TEMPORAL_ACUITY_PRODUCTS 0x0013
#define RTP_MIDI_MANU_LONG_PERFECT_FRETWORKS 0x0014
#define RTP_MIDI_MANU_LONG_KAT 0x0015
#define RTP_MIDI_MANU_LONG_OPCODE 0x0016
#define RTP_MIDI_MANU_LONG_RANE_CORP 0x0017
#define RTP_MIDI_MANU_LONG_SPATIAL_SOUND_ANADI_INC 0x0018
#define RTP_MIDI_MANU_LONG_KMX 0x0019
#define RTP_MIDI_MANU_LONG_ALLEN_AND_HEATH_BRENNEL 0x001a
#define RTP_MIDI_MANU_LONG_PEAVEY 0x001b
#define RTP_MIDI_MANU_LONG_360_SYSTEMS 0x001c
#define RTP_MIDI_MANU_LONG_SPECTRUM_DESIGN_DEVELOPMENT 0x001d
#define RTP_MIDI_MANU_LONG_MARQUIS_MUSIC 0x001e
#define RTP_MIDI_MANU_LONG_ZETA_SYSTEMS 0x001f
#define RTP_MIDI_MANU_LONG_AXXES 0x0020
#define RTP_MIDI_MANU_LONG_ORBAN 0x0021
#define RTP_MIDI_MANU_LONG_INDIAN_VALLEY 0x0022
#define RTP_MIDI_MANU_LONG_TRITON 0x0023
#define RTP_MIDI_MANU_LONG_KTI 0x0024
#define RTP_MIDI_MANU_LONG_BREAKAWAY_TECHNOLOGIES 0x0025
#define RTP_MIDI_MANU_LONG_CAE 0x0026
#define RTP_MIDI_MANU_LONG_HARRISON_SYSTEMS_INC 0x0027
#define RTP_MIDI_MANU_LONG_FUTURE_LAB_MARK_KUO 0x0028
#define RTP_MIDI_MANU_LONG_ROCKTRON_CORP 0x0029
#define RTP_MIDI_MANU_LONG_PIANODISC 0x002a
#define RTP_MIDI_MANU_LONG_CANNON_RESEARCH_GROUP 0x002b
/* #define RTP_MIDI_MANU_LONG_ 0x002c */
#define RTP_MIDI_MANU_LONG_RODGERS_INSTRUMENTS_CORP 0x002d
#define RTP_MIDI_MANU_LONG_BLUE_SKY_LOGIC 0x002e
#define RTP_MIDI_MANU_LONG_ENCORE_ELECTRONICS 0x002f
#define RTP_MIDI_MANU_LONG_UPTOWN 0x0030
#define RTP_MIDI_MANU_LONG_VOCE 0x0031
#define RTP_MIDI_MANU_LONG_CTI_AUDIO_INC 0x0032
#define RTP_MIDI_MANU_LONG_SS_RESEARCH 0x0033
#define RTP_MIDI_MANU_LONG_BRODERBUND_SOFTWARE 0x0034
#define RTP_MIDI_MANU_LONG_ALLEN_ORGAN_CO 0x0035
/* #define RTP_MIDI_MANU_LONG_ 0x0036 */
#define RTP_MIDI_MANU_LONG_MUSIC_QUEST 0x0037
#define RTP_MIDI_MANU_LONG_APHEX 0x0038
#define RTP_MIDI_MANU_LONG_GALLIEN_KRUEGER 0x0039
#define RTP_MIDI_MANU_LONG_IBM 0x003a
#define RTP_MIDI_MANU_LONG_MARK_OF_THE_UNICORN 0x003b
#define RTP_MIDI_MANU_LONG_HOTZ_INSTRUMENTS_TECH 0x003c
#define RTP_MIDI_MANU_LONG_ETA_LIGHTING 0x003d
#define RTP_MIDI_MANU_LONG_NSI_CORPORATION 0x003e
#define RTP_MIDI_MANU_LONG_ADLIB_INC 0x003f
#define RTP_MIDI_MANU_LONG_RICHMOND_SOUND_DESIGN 0x0040
#define RTP_MIDI_MANU_LONG_MICROSOFT 0x0041
#define RTP_MIDI_MANU_LONG_THE_SOFTWARE_TOOLWORKS 0x0042
#define RTP_MIDI_MANU_LONG_RJMG_NICHE 0x0043
#define RTP_MIDI_MANU_LONG_INTONE 0x0044
#define RTP_MIDI_MANU_LONG_ADVANCED_REMOTE_TECH 0x0045
/* #define RTP_MIDI_MANU_LONG_ 0x0046 */
#define RTP_MIDI_MANU_LONG_GT_ELECTRONICS_GROOVE_TUBES 0x0047
#define RTP_MIDI_MANU_LONG_INTERMIDI 0x0048
#define RTP_MIDI_MANU_LONG_TIMELINE_VISTA 0x0049
#define RTP_MIDI_MANU_LONG_MESA_BOOGIE 0x004a
/* #define RTP_MIDI_MANU_LONG_ 0x004b */
#define RTP_MIDI_MANU_LONG_SEQUOIA_DEVELOPMENT 0x004c
#define RTP_MIDI_MANU_LONG_STUDIO_ELECTRONICS 0x004d
#define RTP_MIDI_MANU_LONG_EUPHONIX 0x004e
#define RTP_MIDI_MANU_LONG_INTERMIDI2 0x004f
#define RTP_MIDI_MANU_LONG_MIDI_SOLUTIONS 0x0050
#define RTP_MIDI_MANU_LONG_3DO_COMPANY 0x0051
#define RTP_MIDI_MANU_LONG_LIGHTWAVE_RESEARCH 0x0052
#define RTP_MIDI_MANU_LONG_MICROW 0x0053
#define RTP_MIDI_MANU_LONG_SPECTRAL_SYNTHESIS 0x0054
#define RTP_MIDI_MANU_LONG_LONE_WOLF 0x0055
#define RTP_MIDI_MANU_LONG_STUDIO_TECHNOLOGIES 0x0056
#define RTP_MIDI_MANU_LONG_PETERSON_EMP 0x0057
#define RTP_MIDI_MANU_LONG_ATARI 0x0058
#define RTP_MIDI_MANU_LONG_MARION_SYSTEMS 0x0059
#define RTP_MIDI_MANU_LONG_DESIGN_EVENT 0x005a
#define RTP_MIDI_MANU_LONG_WINJAMMER_SOFTWARE 0x005b
#define RTP_MIDI_MANU_LONG_ATT_BELL_LABS 0x005c
/*# define RTP_MIDI_MANU_LONG_ 0x005d */
#define RTP_MIDI_MANU_LONG_SYMETRIX 0x005e
#define RTP_MIDI_MANU_LONG_MIDI_THE_WORLD 0x005f
#define RTP_MIDI_MANU_LONG_DESPER_PRODUCTS 0x0060
#define RTP_MIDI_MANU_LONG_MICROS_N_MIDI 0x0061
#define RTP_MIDI_MANU_LONG_ACCORDIANS_INTL 0x0062
#define RTP_MIDI_MANU_LONG_EUPHONICS 0x0063
#define RTP_MIDI_MANU_LONG_MUSONIX 0x0064
#define RTP_MIDI_MANU_LONG_TURTLE_BEACH_SYSTEMS 0x0065
#define RTP_MIDI_MANU_LONG_MACKIE_DESIGNS 0x0066
#define RTP_MIDI_MANU_LONG_COMPUSERVE 0x0067
#define RTP_MIDI_MANU_LONG_BES_TECHNOLOGIES 0x0068
#define RTP_MIDI_MANU_LONG_QRS_MUSIC_ROLLS 0x0069
#define RTP_MIDI_MANU_LONG_P_G_MUSIC 0x006a
#define RTP_MIDI_MANU_LONG_SIERRA_SEMICONDUCTOR 0x006b
#define RTP_MIDI_MANU_LONG_EPIGRAF_AUDIO_VISUAL 0x006c
#define RTP_MIDI_MANU_LONG_ELECTRONICS_DIVERSIFIED 0x006d
#define RTP_MIDI_MANU_LONG_TUNE_1000 0x006e
#define RTP_MIDI_MANU_LONG_ADVANCED_MICRO_DEVICES 0x006f
#define RTP_MIDI_MANU_LONG_MEDIAMATION 0x0070
#define RTP_MIDI_MANU_LONG_SABINE_MUSIC 0x0071
#define RTP_MIDI_MANU_LONG_WOOG_LABS 0x0072
#define RTP_MIDI_MANU_LONG_MIRCOPOLIS 0x0073
#define RTP_MIDI_MANU_LONG_TA_HORNG_MUSICAL_INSTRUMENT 0x0074
#define RTP_MIDI_MANU_LONG_ETEK_LABS_FORTE_TECH 0x0075
#define RTP_MIDI_MANU_LONG_ELECTRO_VOICE 0x0076
#define RTP_MIDI_MANU_LONG_MIDISOFT_CORPORATION 0x0077
#define RTP_MIDI_MANU_LONG_QSOUND_LABS 0x0078
#define RTP_MIDI_MANU_LONG_WESTREX 0x0079
#define RTP_MIDI_MANU_LONG_NVIDIA 0x007a
#define RTP_MIDI_MANU_LONG_ESS_TECHNOLOGY 0x007b
#define RTP_MIDI_MANU_LONG_MEDIATRIX_PERIPHERALS 0x007c
#define RTP_MIDI_MANU_LONG_BROOKTREE_CORP 0x007d
#define RTP_MIDI_MANU_LONG_OTARI_CORP 0x007e
#define RTP_MIDI_MANU_LONG_KEY_ELECTRONICS 0x007f
/* ---break--- */
#define RTP_MIDI_MANU_LONG_SHURE_INCORPORATED 0x0100
#define RTP_MIDI_MANU_LONG_AURA_SOUND 0x0101
#define RTP_MIDI_MANU_LONG_CRYSTAL_SEMICONDUCTOR 0x0102
#define RTP_MIDI_MANU_LONG_CONEXANT_ROCKWELL 0x0103
#define RTP_MIDI_MANU_LONG_SILICON_GRAPHICS 0x0104
#define RTP_MIDI_MANU_LONG_MAUDIO_MIDIMAN 0x0105
#define RTP_MIDI_MANU_LONG_PRESONUS 0x0106
/* #define RTP_MIDI_MANU_LONG_ 0x0107 */
#define RTP_MIDI_MANU_LONG_TOPAZ_ENTERPRISES 0x0108
#define RTP_MIDI_MANU_LONG_CAST_LIGHTING 0x0109
#define RTP_MIDI_MANU_LONG_MICROSOFT_CONSUMER_DIVISION 0x010a
#define RTP_MIDI_MANU_LONG_SONIC_FOUNDRY 0x010b
#define RTP_MIDI_MANU_LONG_LINE6_FAST_FORWARD 0x010c
#define RTP_MIDI_MANU_LONG_BEATNIK_INC 0x010d
#define RTP_MIDI_MANU_LONG_VAN_KOEVERING_COMPANY 0x010e
#define RTP_MIDI_MANU_LONG_ALTECH_SYSTEMS 0x010f
#define RTP_MIDI_MANU_LONG_S_S_RESEARCH 0x0110
#define RTP_MIDI_MANU_LONG_VLSI_TECHNOLOGY 0x0111
#define RTP_MIDI_MANU_LONG_CHROMATIC_RESEARCH 0x0112
#define RTP_MIDI_MANU_LONG_SAPPHIRE 0x0113
#define RTP_MIDI_MANU_LONG_IDRC 0x0114
#define RTP_MIDI_MANU_LONG_JUSTONIC_TUNING 0x0115
#define RTP_MIDI_MANU_LONG_TORCOMP_RESEARCH_INC 0x0116
#define RTP_MIDI_MANU_LONG_NEWTEK_INC 0x0117
#define RTP_MIDI_MANU_LONG_SOUND_SCULPTURE 0x0118
#define RTP_MIDI_MANU_LONG_WALKER_TECHNICAL 0x0119
#define RTP_MIDI_MANU_LONG_DIGITAL_HARMONY 0x011a
#define RTP_MIDI_MANU_LONG_INVISION_INTERACTIVE 0x011b
#define RTP_MIDI_MANU_LONG_TSQUARE_DESIGN 0x011c
#define RTP_MIDI_MANU_LONG_NEMESYS_MUSIC_TECHNOLOGY 0x011d
#define RTP_MIDI_MANU_LONG_DBX_PROFESSIONAL_HARMAN_INTL 0x011e
#define RTP_MIDI_MANU_LONG_SYNDYNE_CORPORATION 0x011f
#define RTP_MIDI_MANU_LONG_BITHEADZ 0x0120
#define RTP_MIDI_MANU_LONG_CAKEWALK_MUSIC_SOFTWARE 0x0121
#define RTP_MIDI_MANU_LONG_ANALOG_DEVICES 0x0122
#define RTP_MIDI_MANU_LONG_NATIONAL_SEMICONDUCTOR 0x0123
#define RTP_MIDI_MANU_LONG_BOOM_THEORY 0x0124
#define RTP_MIDI_MANU_LONG_VIRTUAL_DSP_CORPORATION 0x0125
#define RTP_MIDI_MANU_LONG_ANTARES_SYSTEMS 0x0126
#define RTP_MIDI_MANU_LONG_ANGEL_SOFTWARE 0x0127
#define RTP_MIDI_MANU_LONG_ST_LOUIS_MUSIC 0x0128
#define RTP_MIDI_MANU_LONG_LYRRUS_DBA_GVOX 0x0129
#define RTP_MIDI_MANU_LONG_ASHLEY_AUDIO_INC 0x012a
#define RTP_MIDI_MANU_LONG_VARILITE_INC 0x012b
#define RTP_MIDI_MANU_LONG_SUMMIT_AUDIO_INC 0x012c
#define RTP_MIDI_MANU_LONG_AUREAL_SEMICONDUCTOR_INC 0x012d
#define RTP_MIDI_MANU_LONG_SEASOUND_LLC 0x012e
#define RTP_MIDI_MANU_LONG_US_ROBOTICS 0x012f
#define RTP_MIDI_MANU_LONG_AURISIS_RESEARCH 0x0130
#define RTP_MIDI_MANU_LONG_NEARFIELD_MULTIMEDIA 0x0131
#define RTP_MIDI_MANU_LONG_FM7_INC 0x0132
#define RTP_MIDI_MANU_LONG_SWIVEL_SYSTEMS 0x0133
#define RTP_MIDI_MANU_LONG_HYPERACTIVE_AUDIO_SYSTEMS 0x0134
#define RTP_MIDI_MANU_LONG_MIDILITE_CASTE_STUDIO_PROD 0x0135
#define RTP_MIDI_MANU_LONG_RADIKAL_TECHNOLOGIES 0x0136
#define RTP_MIDI_MANU_LONG_ROGER_LINN_DESIGN 0x0137
#define RTP_MIDI_MANU_LONG_TCHELION_VOCAL_TECHNOLOGIES 0x0138
#define RTP_MIDI_MANU_LONG_EVENT_ELECTRONICS 0x0139
#define RTP_MIDI_MANU_LONG_SONIC_NETWORK_INC 0x013a
#define RTP_MIDI_MANU_LONG_REALTIME_MUSIC_SOLUTIONS 0x013b
#define RTP_MIDI_MANU_LONG_APOGEE_DIGITAL 0x013c
#define RTP_MIDI_MANU_LONG_CLASSICAL_ORGANS_INC 0x013d
#define RTP_MIDI_MANU_LONG_MICROTOOLS_INC 0x013e
#define RTP_MIDI_MANU_LONG_NUMARK_INDUSTRIES 0x013f
#define RTP_MIDI_MANU_LONG_FRONTIER_DESIGN_GROUP_LLC 0x0140
#define RTP_MIDI_MANU_LONG_RECORDARE_LLC 0x0141
#define RTP_MIDI_MANU_LONG_STARR_LABS 0x0142
#define RTP_MIDI_MANU_LONG_VOYAGER_SOUND_INC 0x0143
#define RTP_MIDI_MANU_LONG_MANIFOLD_LABS 0x0144
#define RTP_MIDI_MANU_LONG_AVIOM_INC 0x0145
#define RTP_MIDI_MANU_LONG_MIXMEISTER_TECHNOLOGY 0x0146
#define RTP_MIDI_MANU_LONG_NOTATION_SOFTWARE 0x0147
#define RTP_MIDI_MANU_LONG_MERCURIAL_COMMUNICATIONS 0x0148
#define RTP_MIDI_MANU_LONG_WAVE_ARTS 0x0149
#define RTP_MIDI_MANU_LONG_LOGIC_SEQUENCING_DEVICES 0x014a
#define RTP_MIDI_MANU_LONG_AXESS_ELECTRONICS 0x014b
#define RTP_MIDI_MANU_LONG_MUSE_RESEARCH 0x014c
#define RTP_MIDI_MANU_LONG_OPEN_LABS 0x014d
#define RTP_MIDI_MANU_LONG_GUILLEMOT_RD_INC 0x014e
#define RTP_MIDI_MANU_LONG_SAMSON_TECHNOLOGIES 0x014f
#define RTP_MIDI_MANU_LONG_ELECTRONIC_THEATRE_CONTROLS 0x0150
#define RTP_MIDI_MANU_LONG_RESEARCH_IN_MOTION 0x0151
#define RTP_MIDI_MANU_LONG_MOBILEER 0x0152
#define RTP_MIDI_MANU_LONG_SYNTHOGY 0x0153
#define RTP_MIDI_MANU_LONG_LYNX_STUDIO_TECHNOLOGY_INC 0x0154
#define RTP_MIDI_MANU_LONG_DAMAGE_CONTROL_ENGINEERING 0x0155
#define RTP_MIDI_MANU_LONG_YOST_ENGINEERING_INC 0x0156
#define RTP_MIDI_MANU_LONG_BROOKS_FORSMAN_DESIGNS_LLC 0x0157
#define RTP_MIDI_MANU_LONG_MAGNEKEY 0x0158
#define RTP_MIDI_MANU_LONG_GARRITAN_CORP 0x0159
#define RTP_MIDI_MANU_LONG_PLOQUE_ART_ET_TECHNOLOGIE 0x015a
#define RTP_MIDI_MANU_LONG_RJM_MUSIC_TECHNOLOGY 0x015b
#define RTP_MIDI_MANU_LONG_CUSTOM_SOLUTIONS_SOFTWARE 0x015c
#define RTP_MIDI_MANU_LONG_SONARCANA_LLC 0x015d
#define RTP_MIDI_MANU_LONG_CENTRANCE 0x015e
#define RTP_MIDI_MANU_LONG_KESUMO_LLC 0x015f
#define RTP_MIDI_MANU_LONG_STANTON 0x0160
#define RTP_MIDI_MANU_LONG_LIVID_INSTRUMENTS 0x0161
#define RTP_MIDI_MANU_LONG_FIRST_ACT_745_MEDIA 0x0162
#define RTP_MIDI_MANU_LONG_PYGRAPHICS_INC 0x0163
#define RTP_MIDI_MANU_LONG_PANADIGM_INNOVATIONS_LTD 0x0164
#define RTP_MIDI_MANU_LONG_AVEDIS_ZILDJIAN_CO 0x0165
#define RTP_MIDI_MANU_LONG_AUVITAL_MUSIC_CORP 0x0166
#define RTP_MIDI_MANU_LONG_INSPIRED_INSTRUMENTS_INC 0x0167
#define RTP_MIDI_MANU_LONG_CHRIS_GRIGG_DESIGNS 0x0168
#define RTP_MIDI_MANU_LONG_SLATE_DIGITAL_LLC 0x0169
#define RTP_MIDI_MANU_LONG_MIXWARE 0x016a
#define RTP_MIDI_MANU_LONG_SOCIAL_ENTROPY 0x016b
#define RTP_MIDI_MANU_LONG_SOURCE_AUDIO_LLC 0x016c
#define RTP_MIDI_MANU_LONG_RESERVED_016d 0x016d
#define RTP_MIDI_MANU_LONG_RESERVED_016e 0x016e
#define RTP_MIDI_MANU_LONG_RESERVED_016f 0x016f
#define RTP_MIDI_MANU_LONG_AMERICAN_AUDIO_DJ 0x0170
#define RTP_MIDI_MANU_LONG_MEGA_CONTROL_SYSTEMS 0x0171
#define RTP_MIDI_MANU_LONG_KILPATRICK_AUDIO 0x0172
#define RTP_MIDI_MANU_LONG_IKINGDOM_CORP 0x0173
#define RTP_MIDI_MANU_LONG_FRACTAL_AUDIO 0x0174
#define RTP_MIDI_MANU_LONG_NETLOGIC_MICROSYSTEMS 0x0175
#define RTP_MIDI_MANU_LONG_MUSIC_COMPUTING 0x0176
#define RTP_MIDI_MANU_LONG_NEKTAR_TECHNOLOGY_INC 0x0177
#define RTP_MIDI_MANU_LONG_ZENPH_SOUND_INNOVATIONS 0x0178
#define RTP_MIDI_MANU_LONG_DJTECHTOOLS_COM 0x0179
#define RTP_MIDI_MANU_LONG_RESERVED_017a 0x017a

/* European manufacturers */
#define RTP_MIDI_MANU_LONG_DREAM 0x2000
#define RTP_MIDI_MANU_LONG_STRAND_LIGHTING 0x2001
#define RTP_MIDI_MANU_LONG_AMEK_SYSTEMS 0x2002
#define RTP_MIDI_MANU_LONG_CASA_DI_RISPARMIO_DI_LORETO 0x2003
#define RTP_MIDI_MANU_LONG_BOHM_ELECTRONIC 0x2004
#define RTP_MIDI_MANU_LONG_SYNTEC_DIGITAL_AUDIO 0x2005
#define RTP_MIDI_MANU_LONG_TRIDENT_AUDIO 0x2006
#define RTP_MIDI_MANU_LONG_REAL_WORLD_STUDIO 0x2007
#define RTP_MIDI_MANU_LONG_EVOLUTION_SYNTHESIS 0x2008
#define RTP_MIDI_MANU_LONG_YES_TECHNOLOGY 0x2009
#define RTP_MIDI_MANU_LONG_AUDIOMATICA 0x200a
#define RTP_MIDI_MANU_LONG_BONTEMPI_FARFISA 0x200b
#define RTP_MIDI_MANU_LONG_FBT_ELETTRONICA 0x200c
#define RTP_MIDI_MANU_LONG_MIDITEMP 0x200d
#define RTP_MIDI_MANU_LONG_LA_AUDIO_LARKING_AUDIO 0x200e
#define RTP_MIDI_MANU_LONG_ZERO_88_LIGHTING_LIMITED 0x200f
#define RTP_MIDI_MANU_LONG_MICON_AUDIO_ELECTRONICS_GMBH 0x2010
#define RTP_MIDI_MANU_LONG_FOREFRONT_TECHNOLOGY 0x2011
#define RTP_MIDI_MANU_LONG_STUDIO_AUDIO_AND_VIDEO_LTD 0x2012
#define RTP_MIDI_MANU_LONG_KENTON_ELECTRONICS 0x2013
#define RTP_MIDI_MANU_LONG_CELCO_DIVISON_OF_ELECTRONICS 0x2014
#define RTP_MIDI_MANU_LONG_ADB 0x2015
#define RTP_MIDI_MANU_LONG_MARSHALL_PRODUCTS 0x2016
#define RTP_MIDI_MANU_LONG_DDA 0x2017
#define RTP_MIDI_MANU_LONG_BBS 0x2018
#define RTP_MIDI_MANU_LONG_MA_LIGHTING_TECHNOLOGY 0x2019
#define RTP_MIDI_MANU_LONG_FATAR 0x201a
#define RTP_MIDI_MANU_LONG_QSC_AUDIO 0x201b
#define RTP_MIDI_MANU_LONG_ARTISAN_CLASSIC_ORGAN 0x201c
#define RTP_MIDI_MANU_LONG_ORLA_SPA 0x201d
#define RTP_MIDI_MANU_LONG_PINNACLE_AUDIO 0x201e
#define RTP_MIDI_MANU_LONG_TC_ELECTRONICS 0x201f
#define RTP_MIDI_MANU_LONG_DOEPFER_MUSIKELEKTRONIK 0x2020
#define RTP_MIDI_MANU_LONG_CREATIVE_TECHNOLOGY_PTE 0x2021
#define RTP_MIDI_MANU_LONG_MINAMI_SEIYDDO 0x2022
#define RTP_MIDI_MANU_LONG_GOLDSTAR 0x2023
#define RTP_MIDI_MANU_LONG_MIDISOFT_SAS_DI_M_CIMA 0x2024
#define RTP_MIDI_MANU_LONG_SAMICK 0x2025
#define RTP_MIDI_MANU_LONG_PENNY_AND_GILES 0x2026
#define RTP_MIDI_MANU_LONG_ACORN_COMPUTER 0x2027
#define RTP_MIDI_MANU_LONG_LSC_ELECTRONICS 0x2028
#define RTP_MIDI_MANU_LONG_NOVATION_EMS 0x2029
#define RTP_MIDI_MANU_LONG_SAMKYUNG_MECHATRONICS 0x202a
#define RTP_MIDI_MANU_LONG_MEDELI_ELECTRONICS_CO 0x202b
#define RTP_MIDI_MANU_LONG_CHARLIE_LAB_SRL 0x202c
#define RTP_MIDI_MANU_LONG_BLUE_CHIP_MUSIC_TECHNOLOGY 0x202d
#define RTP_MIDI_MANU_LONG_BEE_OH_CORP 0x202e
#define RTP_MIDI_MANU_LONG_LG_SEMICON_AMERICA 0x202f
#define RTP_MIDI_MANU_LONG_TESI 0x2030
#define RTP_MIDI_MANU_LONG_EMAGIC 0x2031
#define RTP_MIDI_MANU_LONG_BEHRINGER_GMBH 0x2032
#define RTP_MIDI_MANU_LONG_ACCESS_MUSIC_ELECTRONICS 0x2033
#define RTP_MIDI_MANU_LONG_SYNOPTIC 0x2034
#define RTP_MIDI_MANU_LONG_HANMESOFT_CORP 0x2035
#define RTP_MIDI_MANU_LONG_TERRATEC_ELECTRONIC_GMBH 0x2036
#define RTP_MIDI_MANU_LONG_PROEL_SPA 0x2037
#define RTP_MIDI_MANU_LONG_IBK_MIDI 0x2038
#define RTP_MIDI_MANU_LONG_IRCAM 0x2039
#define RTP_MIDI_MANU_LONG_PROPELLERHEAD_SOFTWARE 0x203a
#define RTP_MIDI_MANU_LONG_RED_SOUND_SYSTEMS_LTD 0x203b
#define RTP_MIDI_MANU_LONG_ELEKTRON_ESI_AB 0x203c
#define RTP_MIDI_MANU_LONG_SINTEFEX_AUDIO 0x203d
#define RTP_MIDI_MANU_LONG_MAM_MUSIC_AND_MORE 0x203e
#define RTP_MIDI_MANU_LONG_AMSARO_GMBH 0x203f
#define RTP_MIDI_MANU_LONG_CDS_ADVANCED_TECHNOLOGY_BV 0x2040
#define RTP_MIDI_MANU_LONG_TOUCHED_BY_SOUND_GMBH 0x2041
#define RTP_MIDI_MANU_LONG_DSP_ARTS 0x2042
#define RTP_MIDI_MANU_LONG_PHIL_REES_MUSIC_TECH 0x2043
#define RTP_MIDI_MANU_LONG_STAMER_MUSIKANLAGEN_GMBH 0x2044
#define RTP_MIDI_MANU_LONG_MUSICAL_MUNTANER_SA_DBA 0x2045
#define RTP_MIDI_MANU_LONG_CMEXX_SOFTWARE 0x2046
#define RTP_MIDI_MANU_LONG_KLAVIS_TECHNOLOGIES 0x2047
#define RTP_MIDI_MANU_LONG_NOTEHEADS_AB 0x2048
#define RTP_MIDI_MANU_LONG_ALGORITHMIX 0x2049
#define RTP_MIDI_MANU_LONG_SKRYDSTRUP_RD 0x204a
#define RTP_MIDI_MANU_LONG_PROFRESSIONAL_AUDIO_COMPANY 0x204b
#define RTP_MIDI_MANU_LONG_DBTECH_MADWAVES 0x204c
#define RTP_MIDI_MANU_LONG_VERMONA 0x204d
#define RTP_MIDI_MANU_LONG_NOKIA 0x204e
#define RTP_MIDI_MANU_LONG_WAVE_IDEA 0x204f
#define RTP_MIDI_MANU_LONG_HARTMANN_GMBH 0x2050
#define RTP_MIDI_MANU_LONG_LIONS_TRACK 0x2051
#define RTP_MIDI_MANU_LONG_ANALOGUE_SYSTEMS 0x2052
#define RTP_MIDI_MANU_LONG_FOCAL_JMLAB 0x2053
#define RTP_MIDI_MANU_LONG_RINGWAY_ELECTRONICS 0x2054
#define RTP_MIDI_MANU_LONG_FAITH_TECHNOLOGIES_DIGIPLUG 0x2055
#define RTP_MIDI_MANU_LONG_SHOWWORKS 0x2056
#define RTP_MIDI_MANU_LONG_MANIKIN_ELECTRONIC 0x2057
#define RTP_MIDI_MANU_LONG_1_COME_TECH 0x2058
#define RTP_MIDI_MANU_LONG_PHONIC_CORP 0x2059
#define RTP_MIDI_MANU_LONG_LAKE_TECHNOLOGY 0x205a
#define RTP_MIDI_MANU_LONG_SILANSYS_TECHNOLOGIES 0x205b
#define RTP_MIDI_MANU_LONG_WINBOND_ELECTRONICS 0x205c
#define RTP_MIDI_MANU_LONG_CINETIX_MEDIEN_UND_INTERFACE 0x205d
#define RTP_MIDI_MANU_LONG_AG_SOLUTIONI_DIGITALI 0x205e
#define RTP_MIDI_MANU_LONG_SEQUENTIX_MUSIC_SYSTEMS 0x205f
#define RTP_MIDI_MANU_LONG_ORAM_PRO_AUDIO 0x2060
#define RTP_MIDI_MANU_LONG_BE4_LTD 0x2061
#define RTP_MIDI_MANU_LONG_INFECTION_MUSIC 0x2062
#define RTP_MIDI_MANU_LONG_CENTRAL_MUSIC_CO_CME 0x2063
#define RTP_MIDI_MANU_LONG_GENOQS_MACHINES 0x2064
#define RTP_MIDI_MANU_LONG_MEDIALON 0x2065
#define RTP_MIDI_MANU_LONG_WAVES_AUDIO_LTD 0x2066
#define RTP_MIDI_MANU_LONG_JERASH_LABS 0x2067
#define RTP_MIDI_MANU_LONG_DA_FACT 0x2068
#define RTP_MIDI_MANU_LONG_ELBY_DESIGNS 0x2069
#define RTP_MIDI_MANU_LONG_SPECTRAL_AUDIO 0x206a
#define RTP_MIDI_MANU_LONG_ARTURIA 0x206b
#define RTP_MIDI_MANU_LONG_VIXID 0x206c
#define RTP_MIDI_MANU_LONG_C_THRU_MUSIC 0x206d
#define RTP_MIDI_MANU_LONG_YA_HORNG_ELECTRONIC_CO_LTD 0x206e
#define RTP_MIDI_MANU_LONG_SM_PRO_AUDIO 0x206f
#define RTP_MIDI_MANU_LONG_OTO_MACHINES 0x2070
#define RTP_MIDI_MANU_LONG_ELZAB_SA_G_LAB 0x2071
#define RTP_MIDI_MANU_LONG_BLACKSTAR_AMPLIFICATION_LTD 0x2072
#define RTP_MIDI_MANU_LONG_M3I_TECHNOLOGIES_GMBH 0x2073
#define RTP_MIDI_MANU_LONG_GEMALTO 0x2074
#define RTP_MIDI_MANU_LONG_PROSTAGE_SL 0x2075
#define RTP_MIDI_MANU_LONG_TEENAGE_ENGINEERING 0x2076
#define RTP_MIDI_MANU_LONG_TOBIAS_ERICHSEN 0x2077
#define RTP_MIDI_MANU_LONG_NIXER_LTD 0x2078
#define RTP_MIDI_MANU_LONG_HANPIN_ELECTRON_CO_LTD 0x2079
#define RTP_MIDI_MANU_LONG_MIDI_HARDWARE_R_SOWA 0x207a

#define RTP_MIDI_MANU_LONG_BEYOND_MUSIC_INDUSTRIAL_LTD 0x207b
#define RTP_MIDI_MANU_LONG_KISS_BOX_BV 0x207c
#define RTP_MIDI_MANU_LONG_MISA_DIGITAL_TECHNOLOGIES_LTD 0x207d
#define RTP_MIDI_MANU_LONG_AI_MUSICS_TECHNOLOGY_INC 0x207e
#define RTP_MIDI_MANU_LONG_SERATO_INC_LP 0x207f
#define RTP_MIDI_MANU_LONG_LIMEX_MUSIC_HANDLES_GMBH 0x2100
#define RTP_MIDI_MANU_LONG_KYODDAY_TOKAI 0x2101
#define RTP_MIDI_MANU_LONG_MUTABLE_INSTRUMENTS 0x2102
#define RTP_MIDI_MANU_LONG_PRESONUS_SOFTWARE_LTD 0x2103
#define RTP_MIDI_MANU_LONG_XIRING 0x2104
#define RTP_MIDI_MANU_LONG_FAIRLIGHT_INTRUMENTS_PTY_LTD 0x2105
#define RTP_MIDI_MANU_LONG_MUSICOM_LAB 0x2106
#define RTP_MIDI_MANU_LONG_VACO_LOCO 0x2107
#define RTP_MIDI_MANU_LONG_RWA_HONG_KONG_LIMITED 0x2108

/* Japanese Manufacturers */
#define RTP_MIDI_MANU_LONG_CRIMSON_TECHNOLOGY_INC 0x4000
#define RTP_MIDI_MANU_LONG_SOFTBANK_MOBILE_CORP 0x4001
/*#define RTP_MIDI_MANU_LONG_*/
#define RTP_MIDI_MANU_LONG_DM_HOLDINGS_INC 0x4003


#define RTP_MIDI_SYSEX_COMMON_NRT_DLS_LEVEL1_ON 0x01
#define RTP_MIDI_SYSEX_COMMON_NRT_DLS_LEVEL1_OFF 0x02
#define RTP_MIDI_SYSEX_COMMON_NRT_DLS_LEVEL1_VOICE_ALLOCATION_OFF 0x03
#define RTP_MIDI_SYSEX_COMMON_NRT_DLS_LEVEL1_VOICE_ALLOCATION_ON 0x04


#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_SPECIAL 0x00
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_PUNCH_IN_POINTS 0x01
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_PUNGH_OUT_POINTS 0x02
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_DELETE_PUNCH_IN_POINTS 0x03
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_DELETE_PUNCH_OUT_POINTS 0x04
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_EVENT_START_POINT 0x05
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_EVENT_STOP_POINT 0x06
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_EVENT_START_POINT_ADD 0x07
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_EVENT_STOP_POINT_ADD 0x08
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_DELETE_EVENT_START_POINT 0x09
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_DELETE_EVENT_STOP_POINT 0x0a
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_CUE_POINTS 0x0b
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_CUE_POINTS_ADD 0x0c
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_DELETE_CUE_POINT 0x0d
#define RTP_MIDI_SYSEX_COMMON_NRT_MTC_EVENT_NAME_IN_ADD 0x0e

#define RTP_MIDI_SYSEX_COMMON_NRT_SD_EXT_LOOP_POINT_TRANSMISSION 0x01
#define RTP_MIDI_SYSEX_COMMON_NRT_SD_EXT_LOOP_POINTS_REQUEST 0x02

#define RTP_MIDI_SYSEX_COMMON_NRT_SD_EXT_LP_UNI 0x00
#define RTP_MIDI_SYSEX_COMMON_NRT_SD_EXT_LP_BI 0x01
#define RTP_MIDI_SYSEX_COMMON_NRT_SD_EXT_LP_OFF 0x7f

#define RTP_MIDI_SYSEX_COMMON_NRT_GI_IDENTITY_REQUEST 0x01
#define RTP_MIDI_SYSEX_COMMON_NRT_GI_IDENTITY_REPLY 0x02

#define RTP_MIDI_SYSEX_COMMON_NRT_FD_HEADER 0x01
#define RTP_MIDI_SYSEX_COMMON_NRT_FD_DATA_PACKET 0x02
#define RTP_MIDI_SYSEX_COMMON_NRT_FD_REQUEST 0x03

#define RTP_MIDI_SYSEX_COMMON_TUNING_BULK_DUMP_REQUEST 0x00
#define RTP_MIDI_SYSEX_COMMON_TUNING_BULK_DUMP_REPLY 0x01
#define RTP_MIDI_SYSEX_COMMON_TUNING_NOTE_CHANGE 0x02

#define RTP_MIDI_SYSEX_COMMON_NRT_GM_ON 0x01
#define RTP_MIDI_SYSEX_COMMON_NRT_GM_OFF 0x02

#define RTP_MIDI_SYSEX_COMMON_RT_MTC_FULL_MESSAGE 0x01
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_USER_BITS 0x02

#define RTP_MIDI_SYSEX_COMMON_RT_SCL_EXTENSIONS 0x00
#define RTP_MIDI_SYSEX_COMMON_RT_SC_LIGHTING 0x01
#define RTP_MIDI_SYSEX_COMMON_RT_SC_MOVING_LIGHTS 0x02
#define RTP_MIDI_SYSEX_COMMON_RT_SC_COLOR_CHANGERS 0x03
#define RTP_MIDI_SYSEX_COMMON_RT_SC_STROBES 0x04
#define RTP_MIDI_SYSEX_COMMON_RT_SCL_LASERS 0x05
#define RTP_MIDI_SYSEX_COMMON_RT_SCL_CHASERS 0x06
#define RTP_MIDI_SYSEX_COMMON_RT_SC_SOUND 0x10
#define RTP_MIDI_SYSEX_COMMON_RT_SC_MUSIC 0x11
#define RTP_MIDI_SYSEX_COMMON_RT_SC_CD_PLAYERS 0x12
#define RTP_MIDI_SYSEX_COMMON_RT_SC_EPROM_PLAYBACK 0x13
#define RTP_MIDI_SYSEX_COMMON_RT_SCL_AUDIO_TAPE_MACHINE 0x14
#define RTP_MIDI_SYSEX_COMMON_RT_SC_INTERCOMS 0x15
#define RTP_MIDI_SYSEX_COMMON_RT_SC_AMPLIFIERS 0x16
#define RTP_MIDI_SYSEX_COMMON_RT_SC_AUDIO_EFFECTS 0x17
#define RTP_MIDI_SYSEX_COMMON_RT_SC_EQUALIZERS 0x18
#define RTP_MIDI_SYSEX_COMMON_RT_SC_MACHINERY 0x20
#define RTP_MIDI_SYSEX_COMMON_RT_SC_RIGGING 0x21
#define RTP_MIDI_SYSEX_COMMON_RT_SC_FLYS 0x22
#define RTP_MIDI_SYSEX_COMMON_RT_SC_LIFTS 0x23
#define RTP_MIDI_SYSEX_COMMON_RT_SC_TURNTABLES 0x24
#define RTP_MIDI_SYSEX_COMMON_RT_SC_TRUSSES 0x25
#define RTP_MIDI_SYSEX_COMMON_RT_SC_ROBOTS 0x26
#define RTP_MIDI_SYSEX_COMMON_RT_SC_ANIMATION 0x27
#define RTP_MIDI_SYSEX_COMMON_RT_SC_FLOATS 0x28
#define RTP_MIDI_SYSEX_COMMON_RT_SC_BREAKAWAYS 0x29
#define RTP_MIDI_SYSEX_COMMON_RT_SC_BARGES 0x2a
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO 0x30
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO_TAPE_MACHINES 0x31
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO_CASSETTE_MACHINES 0x32
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO_DISC_PLAYERS 0x33
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO_SWITCHERS 0x34
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO_EFFECT 0x35
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO_CHARACTER_GENERATORS 0x36
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO_STIL_STORES 0x37
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO_MONITORS 0x38
#define RTP_MIDI_SYSEX_COMMON_RT_SC_PROJECTION 0x40
#define RTP_MIDI_SYSEX_COMMON_RT_SC_FILM_PROJECTORS 0x41
#define RTP_MIDI_SYSEX_COMMON_RT_SC_SLIDE_PROJECTORS 0x42
#define RTP_MIDI_SYSEX_COMMON_RT_SC_VIDEO_PROJECTORS 0x43
#define RTP_MIDI_SYSEX_COMMON_RT_SC_DISSOLVERS 0x44
#define RTP_MIDI_SYSEX_COMMON_RT_SC_SHUTTER_CONTROLS 0x45
#define RTP_MIDI_SYSEX_COMMON_RT_SC_PROCESS_CONTROL 0x50
#define RTP_MIDI_SYSEX_COMMON_RT_SC_HYDRAULIC_OIL 0x51
#define RTP_MIDI_SYSEX_COMMON_RT_SC_H2O 0x52
#define RTP_MIDI_SYSEX_COMMON_RT_SC_CO2 0x53
#define RTP_MIDI_SYSEX_COMMON_RT_SC_COMPRESSED_AIR 0x54
#define RTP_MIDI_SYSEX_COMMON_RT_SC_NATURAL_GAS 0x55
#define RTP_MIDI_SYSEX_COMMON_RT_SC_FOG 0x56
#define RTP_MIDI_SYSEX_COMMON_RT_SC_SMOKE 0x57
#define RTP_MIDI_SYSEX_COMMON_RT_SC_CRACKED_HAZE 0x58
#define RTP_MIDI_SYSEX_COMMON_RT_SC_PYRO 0x60
#define RTP_MIDI_SYSEX_COMMON_RT_SC_FIREWORKS 0x61
#define RTP_MIDI_SYSEX_COMMON_RT_SC_EXPLOSIONS 0x62
#define RTP_MIDI_SYSEX_COMMON_RT_SC_FLAME 0x63
#define RTP_MIDI_SYSEX_COMMON_RT_SC_SMOKE_POTS 0x64
#define RTP_MIDI_SYSEX_COMMON_RT_SC_ALL_TYPES 0x7f

#define RTP_MIDI_SYSEX_COMMON_RT_NT_BAR_NUMBER 0x01
#define RTP_MIDI_SYSEX_COMMON_RT_NT_TIME_SIGNATURE_IMMEDIATE 0x02
#define RTP_MIDI_SYSEX_COMMON_RT_NT_TIME_SIGNATURE_DELAYED 0x42

#define RTP_MIDI_SYSEX_COMMON_RT_DC_MASTER_VOLUME 0x01
#define RTP_MIDI_SYSEX_COMMON_RT_DC_MASTER_BALANCE 0x02

#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_SPECIAL 0x00
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_PUNCH_IN_POINTS 0x01
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_PUNCH_OUT_POINTS 0x02
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_RESERVED_03 0x03
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_RESERVED_04 0x04
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_EVENT_START_POINTS 0x05
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_EVENT_STOP_POINTS 0x06
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_EVENT_START_POINTS_ADD 0x07
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_EVENT_STOP_POINTS_ADD 0x08
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_RESERVED_09 0x09
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_RESERVED_0A 0x0a
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_CUE_POINTS 0x0b
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_CUE_POINTS_ADD 0x0c
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_RESERVED_0D 0x0d
#define RTP_MIDI_SYSEX_COMMON_RT_MTC_CUE_EVENT_NAME_ADD 0x0e

/* TODO: Add MMC Commands */

/* TODO: Add MMC Responses */

#define RTP_MIDI_COMMON_MTC_QF_FRAME_LS_NIBBLE 0x00
#define RTP_MIDI_COMMON_MTC_QF_FRAME_MS_NIBBLE 0x01
#define RTP_MIDI_COMMON_MTC_QF_SECONDS_LS_NIBBLE 0x02
#define RTP_MIDI_COMMON_MTC_QF_SECONDS_MS_NIBBLE 0x03
#define RTP_MIDI_COMMON_MTC_QF_MINUTES_LS_NIBBLE 0x04
#define RTP_MIDI_COMMON_MTC_QF_MINUTES_MS_NIBBLE 0x05
#define RTP_MIDI_COMMON_MTC_QF_HOURS_LS_NIBBLE 0x06
#define RTP_MIDI_COMMON_MTC_QF_HOURS_MS_NIBBLE 0x07

// Strings from Wireshark
/*
#define RTP_MIDI_TREE_NAME_COMMAND "Command Section"
#define RTP_MIDI_TREE_NAME_COMMAND_SYSEX_MANU "Manufacturer specific data"
#define RTP_MIDI_TREE_NAME_COMMAND_SYSEX_EDU "Educational data"
#define RTP_MIDI_TREE_NAME_JOURNAL "Journal Section"
#define RTP_MIDI_TREE_NAME_SYSTEM_JOURNAL "System-Journal"
#define RTP_MIDI_TREE_NAME_SYSTEM_CHAPTERS "System-Chapters"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_D "Simple System Commands"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_D_FIELD_B "Reset Field"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_D_FIELD_G "Tune Request Field"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_D_FIELD_H "Song Select Field"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_D_FIELD_J "System Common 0xF4"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_D_FIELD_K "System Common 0xF5"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_D_FIELD_Y "System Common 0xF9"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_D_FIELD_Z "System Common 0xFD"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_V "Active Sensing"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_Q "Sequencer State Commands"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_F "MIDI Time Code Tape Position"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_F_COMPLETE "Complete field"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_F_PARTIAL "Partial field"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_X "System Exclusive"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_X_DATA "Data field (sysex commands)"
#define RTP_MIDI_TREE_NAME_SJ_CHAPTER_X_INVALID_DATA "Data field (invalid sysex commands)"
#define RTP_MIDI_TREE_NAME_CHANNEL_JOURNAL "Channel-Journal"
#define RTP_MIDI_TREE_NAME_CHANNEL_CHAPTERS "Channel-Chapters"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_P "Program Change"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_C "Control Change"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_C_LOGLIST "Log List"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_C_LOGITEM "Log Item"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_M "Parameter System"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_M_LOGLIST "Log List"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_M_LOGITEM "Log Item"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_M_LOG_MSB "Entry MSB"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_M_LOG_LSB "Entry LSB"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_M_LOG_A_BUTTON "A-Button"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_M_LOG_C_BUTTON "C-Button"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_M_LOG_COUNT "Count"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_W "Pitch Wheel"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_N "Note on/off"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_N_LOGLIST "Log List"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_N_LOGITEM "Note On"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_N_OCTETS "Offbit Octets"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_E "Note Command Extras"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_E_LOGLIST "Log List"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_E_LOGITEM1 "Note Off"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_E_LOGITEM2 "Note On/Off"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_T "Channel Aftertouch"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_A "Poly Aftertouch"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_A_LOGLIST "Log List"
#define RTP_MIDI_TREE_NAME_CJ_CHAPTER_A_LOGITEM "Pressure"
*/

/* used to mask the most significant bit, which flags the start of a new midi-command! */
#define RTP_MIDI_COMMAND_STATUS_FLAG 0x80

/* used to mask the lower 7 bits of the single octets that make up the delta-time */
#define RTP_MIDI_DELTA_TIME_OCTET_MASK 0x7f
/* used to mask the most significant bit, which flags the extension of the delta-time */
#define RTP_MIDI_DELTA_TIME_EXTENSION 0x80

#define RTP_MIDI_CS_FLAG_B 0x80
#define RTP_MIDI_CS_FLAG_J 0x40
#define RTP_MIDI_CS_FLAG_Z 0x20
#define RTP_MIDI_CS_FLAG_P 0x10
#define RTP_MIDI_CS_MASK_SHORTLEN 0x0f
#define RTP_MIDI_CS_MASK_LONGLEN 0x0fff

#define RTP_MIDI_CJ_CHAPTER_M_FLAG_J 0x80
#define RTP_MIDI_CJ_CHAPTER_M_FLAG_K 0x40
#define RTP_MIDI_CJ_CHAPTER_M_FLAG_L 0x20
#define RTP_MIDI_CJ_CHAPTER_M_FLAG_M 0x10
#define RTP_MIDI_CJ_CHAPTER_M_FLAG_N 0x08
#define RTP_MIDI_CJ_CHAPTER_M_FLAG_T 0x04
#define RTP_MIDI_CJ_CHAPTER_M_FLAG_V 0x02
#define RTP_MIDI_CJ_CHAPTER_M_FLAG_R 0x01

#define RTP_MIDI_JS_FLAG_S 0x80
#define RTP_MIDI_JS_FLAG_Y 0x40
#define RTP_MIDI_JS_FLAG_A 0x20
#define RTP_MIDI_JS_FLAG_H 0x10
#define RTP_MIDI_JS_MASK_TOTALCHANNELS 0x0f

#define RTP_MIDI_SJ_FLAG_S 0x8000
#define RTP_MIDI_SJ_FLAG_D 0x4000
#define RTP_MIDI_SJ_FLAG_V 0x2000
#define RTP_MIDI_SJ_FLAG_Q 0x1000
#define RTP_MIDI_SJ_FLAG_F 0x0800
#define RTP_MIDI_SJ_FLAG_X 0x0400
#define RTP_MIDI_SJ_MASK_LENGTH 0x03ff

#define RTP_MIDI_SJ_CHAPTER_D_FLAG_S 0x80
#define RTP_MIDI_SJ_CHAPTER_D_FLAG_B 0x40
#define RTP_MIDI_SJ_CHAPTER_D_FLAG_G 0x20
#define RTP_MIDI_SJ_CHAPTER_D_FLAG_H 0x10
#define RTP_MIDI_SJ_CHAPTER_D_FLAG_J 0x08
#define RTP_MIDI_SJ_CHAPTER_D_FLAG_K 0x04
#define RTP_MIDI_SJ_CHAPTER_D_FLAG_Y 0x02
#define RTP_MIDI_SJ_CHAPTER_D_FLAG_Z 0x01

#define RTP_MIDI_SJ_CHAPTER_D_RESET_FLAG_S 0x80
#define RTP_MIDI_SJ_CHAPTER_D_RESET_COUNT 0x7f
#define RTP_MIDI_SJ_CHAPTER_D_TUNE_FLAG_S 0x80
#define RTP_MIDI_SJ_CHAPTER_D_TUNE_COUNT 0x7f
#define RTP_MIDI_SJ_CHAPTER_D_SONG_SEL_FLAG_S 0x80
#define RTP_MIDI_SJ_CHAPTER_D_SONG_SEL_VALUE 0x7f

#define RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_S 0x8000
#define RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_C 0x4000
#define RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_V 0x2000
#define RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_L 0x1000
#define RTP_MIDI_SJ_CHAPTER_D_SYSCOM_MASK_DSZ 0x0c00
#define RTP_MIDI_SJ_CHAPTER_D_SYSCOM_MASK_LENGTH 0x03ff
#define RTP_MIDI_SJ_CHAPTER_D_SYSCOM_MASK_COUNT 0xff

#define RTP_MIDI_SJ_CHAPTER_D_SYSREAL_FLAG_S 0x80
#define RTP_MIDI_SJ_CHAPTER_D_SYSREAL_FLAG_C 0x40
#define RTP_MIDI_SJ_CHAPTER_D_SYSREAL_FLAG_L 0x20
#define RTP_MIDI_SJ_CHAPTER_D_SYSREAL_MASK_LENGTH 0x1f
#define RTP_MIDI_SJ_CHAPTER_D_SYSREAL_MASK_COUNT 0xff

#define RTP_MIDI_SJ_CHAPTER_Q_FLAG_S 0x80
#define RTP_MIDI_SJ_CHAPTER_Q_FLAG_N 0x40
#define RTP_MIDI_SJ_CHAPTER_Q_FLAG_D 0x20
#define RTP_MIDI_SJ_CHAPTER_Q_FLAG_C 0x10
#define RTP_MIDI_SJ_CHAPTER_Q_FLAG_T 0x80
#define RTP_MIDI_SJ_CHAPTER_Q_MASK_TOP 0x07
#define RTP_MIDI_SJ_CHAPTER_Q_MASK_CLOCK 0x07ffff
#define RTP_MIDI_SJ_CHAPTER_Q_MASK_TIMETOOLS 0xffffff

#define RTP_MIDI_SJ_CHAPTER_F_FLAG_S 0x80
#define RTP_MIDI_SJ_CHAPTER_F_FLAG_C 0x40
#define RTP_MIDI_SJ_CHAPTER_F_FLAG_P 0x20
#define RTP_MIDI_SJ_CHAPTER_F_FLAG_Q 0x10
#define RTP_MIDI_SJ_CHAPTER_F_FLAG_D 0x08
#define RTP_MIDI_SJ_CHAPTER_F_MASK_POINT 0x07
#define RTP_MIDI_SJ_CHAPTER_F_MASK_MT0 0xf0000000
#define RTP_MIDI_SJ_CHAPTER_F_MASK_MT1 0x0f000000
#define RTP_MIDI_SJ_CHAPTER_F_MASK_MT2 0x00f00000
#define RTP_MIDI_SJ_CHAPTER_F_MASK_MT3 0x000f0000
#define RTP_MIDI_SJ_CHAPTER_F_MASK_MT4 0x0000f000
#define RTP_MIDI_SJ_CHAPTER_F_MASK_MT5 0x00000f00
#define RTP_MIDI_SJ_CHAPTER_F_MASK_MT6 0x000000f0
#define RTP_MIDI_SJ_CHAPTER_F_MASK_MT7 0x0000000f
#define RTP_MIDI_SJ_CHAPTER_F_MASK_HR 0xff000000
#define RTP_MIDI_SJ_CHAPTER_F_MASK_MN 0x00ff0000
#define RTP_MIDI_SJ_CHAPTER_F_MASK_SC 0x0000ff00
#define RTP_MIDI_SJ_CHAPTER_F_MASK_FR 0x000000ff

#define RTP_MIDI_SJ_CHAPTER_X_FLAG_S 0x80
#define RTP_MIDI_SJ_CHAPTER_X_FLAG_T 0x40
#define RTP_MIDI_SJ_CHAPTER_X_FLAG_C 0x20
#define RTP_MIDI_SJ_CHAPTER_X_FLAG_F 0x10
#define RTP_MIDI_SJ_CHAPTER_X_FLAG_D 0x08
#define RTP_MIDI_SJ_CHAPTER_X_FLAG_L 0x04
#define RTP_MIDI_SJ_CHAPTER_X_MASK_STA 0x03
#define RTP_MIDI_SJ_CHAPTER_X_MASK_TCOUNT 0xff
#define RTP_MIDI_SJ_CHAPTER_X_MASK_COUNT 0xff

#define RTP_MIDI_CJ_FLAG_S 0x800000
#define RTP_MIDI_CJ_FLAG_H 0x040000
#define RTP_MIDI_CJ_FLAG_P 0x000080
#define RTP_MIDI_CJ_FLAG_C 0x000040
#define RTP_MIDI_CJ_FLAG_M 0x000020
#define RTP_MIDI_CJ_FLAG_W 0x000010
#define RTP_MIDI_CJ_FLAG_N 0x000008
#define RTP_MIDI_CJ_FLAG_E 0x000004
#define RTP_MIDI_CJ_FLAG_T 0x000002
#define RTP_MIDI_CJ_FLAG_A 0x000001
#define RTP_MIDI_CJ_MASK_LENGTH 0x03ff00
#define RTP_MIDI_CJ_MASK_CHANNEL 0x780000
#define RTP_MIDI_CJ_CHANNEL_SHIFT 19

#define RTP_MIDI_CJ_CHAPTER_M_MASK_LENGTH 0x3f

#define RTP_MIDI_CJ_CHAPTER_N_MASK_LENGTH 0x7f00
#define RTP_MIDI_CJ_CHAPTER_N_MASK_LOW 0x00f0
#define RTP_MIDI_CJ_CHAPTER_N_MASK_HIGH 0x000f

#define RTP_MIDI_CJ_CHAPTER_E_MASK_LENGTH 0x7f
#define RTP_MIDI_CJ_CHAPTER_A_MASK_LENGTH 0x7f


class PacketRtpMidi {

public:
	PacketRtpMidi() {
		#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("PacketRtpMidi verbose");
		#endif
	}

	static int dissect_rtp_midi(Dissector* dissector, IAppleMidi* appleMidi, unsigned char* packetBuffer, size_t packetSize) {
		#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.print ("dissect_rtp_midi ");
		Serial.print (dissector->_identifier);
		Serial.print (", packetSize is ");
		Serial.println (packetSize);
		#endif

		int consumed = PacketRtp::dissect_rtp(dissector, appleMidi, packetBuffer, packetSize);

		if (consumed <= 0) {
			#ifdef APPLEMIDI_DEBUG_VERBOSE
			Serial.println("Unprocessed packet (No valid rtp midi content).");
			#endif
			return 0;
		}

		int offset = consumed;
		int totchan = 0;
		unsigned int	rsoffset = 0;

		/*
		* MIDI command section
		*/

		/* RTP-MIDI starts with 4 bits of flags... */
		uint8_t flags = packetBuffer[offset];

		/* ...followed by a length-field of at least 4 bits */
		unsigned int cmd_len = flags & RTP_MIDI_CS_MASK_SHORTLEN;

		#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.print ("cmd_len is ");
		Serial.println (cmd_len);
		#endif

		/* see if we have small or large len-field */
		if (flags & RTP_MIDI_CS_FLAG_B) {
			uint8_t	octet = packetBuffer[offset + 1];
			cmd_len	= ( cmd_len << 8 ) | octet;
			offset	+= 2;
		} else {
			offset++;
		}

		/* if we have a command-section -> dissect it */
		if (cmd_len) {
			#ifdef APPLEMIDI_DEBUG_VERBOSE
			Serial.print ("dissect command section with packet size ");
			Serial.println (packetSize);
			#endif

			/* No commands decoded yet */
			int cmd_count = 0;

			/* RTP-MIDI-pdus always start with no running status */
			byte runningstatus = 0;

			/* Multiple MIDI-commands might follow - the exact number can only be discovered by really decoding the commands! */
			while (cmd_len) {
				#ifdef APPLEMIDI_DEBUG_VERBOSE
				Serial.print ("cmd count is ");
				Serial.println (cmd_count);
				#endif

				/* for the first command we only have a delta-time if Z-Flag is set */
				if ( (cmd_count) || (flags & RTP_MIDI_CS_FLAG_Z) ) {
					/* Decode a delta-time - if 0 is returned something went wrong */
					int consumed = decodetime(appleMidi, packetBuffer, offset, cmd_len);
					if ( -1 == consumed ) {
						#ifdef APPLEMIDI_DEBUG
						Serial.print ("ReportedBoundsError 1");
						#endif

						return offset;
					}

					/* seek to next command and set remaining length */
					offset += consumed;
					cmd_len -= consumed;
				}

				/* Only decode MIDI-command if there is any data left - it is valid to only have delta-time! */
				if (cmd_len) {
					/* Decode a MIDI-command - if 0 is returned something went wrong */
					int consumed = decodemidi(appleMidi, packetBuffer, cmd_count, offset, cmd_len, &runningstatus, &rsoffset);
					if (-1 == consumed) {
						#ifdef APPLEMIDI_DEBUG
						Serial.print ("ReportedBoundsError 2");
						#endif

						return offset;
					}

					/* seek to next delta-time and set remaining length */
					offset += consumed;
					cmd_len -= consumed;

					/* as we have successfully decoded another command, increment count */
					cmd_count++;
				}
			}
		}

		/*
		* Journal section
		*/

		/* if we have a journal-section -> dissect it */
		if ( flags & RTP_MIDI_CS_FLAG_J ) {
			#ifdef APPLEMIDI_DEBUG_VERBOSE
			Serial.println("journal section");
			#endif

			/* lets get the main flags from the recovery journal header */
			flags = packetBuffer[offset];

			/* At the same place we find the total channels encoded in the channel journal */
			totchan = flags & RTP_MIDI_JS_MASK_TOTALCHANNELS;
			offset++;

			/* the checkpoint-sequence-number can be used to see if the recovery journal covers all lost events */
			offset += 2;

			/* do we have system journal? */
			if ( flags & RTP_MIDI_JS_FLAG_Y ) {
				/* first we need to get the flags & length from the system-journal */
				int consumed = decode_system_journal(appleMidi, packetBuffer, offset);

				if ( -1 == consumed ) {
					#ifdef APPLEMIDI_DEBUG
					Serial.print ("ReportedBoundsError 3");
					#endif

					return offset;
				}

				/* seek to optional channel-journals-section */
				offset += consumed;
			}

			/* do we have channel journal(s)? */
			if ( flags & RTP_MIDI_JS_FLAG_A	 ) {
				/* iterate through all the channels specified in header */
				for (int i = 0; i <= totchan; i++ ) {
					#ifdef APPLEMIDI_DEBUG_VERBOSE
					Serial.print("Processing channel journal: ");
					Serial.println(i);
					#endif

					int consumed = decode_channel_journal(appleMidi, packetBuffer, offset);

					#ifdef APPLEMIDI_DEBUG_VERBOSE
					Serial.print("Consumed by channel journal (");
					Serial.print(i);
					Serial.print("): ");
					Serial.println(consumed);
					#endif

					if ( -1 == consumed ) {
						#ifdef APPLEMIDI_DEBUG
						Serial.println("ReportedBoundsError 4");
						#endif

						return offset;
					}

					/* seek to next channel-journal */
					offset += consumed;
				}
			}
		}

		return offset;
	}

	/*
	* Here the system-journal is decoded.
	*/
	static int
	decode_system_journal(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset)
	{
		#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_system_journal");
		#endif
		unsigned int start_offset = offset;
		int				consumed     = 0;
		int				ext_consumed = 0;

		uint16_t systemflags = packetBuffer[offset]; // 2 bytes!!! tvb_get_ntohs
		uint16_t sysjourlen  = systemflags & RTP_MIDI_SJ_MASK_LENGTH;

		offset	 += 2;
		consumed += 2;

		/* Do we have a simple system commands chapter? */
		if ( systemflags & RTP_MIDI_SJ_FLAG_D ) {
			offset += decode_sj_chapter_d(rtpMidi, packetBuffer, offset );
		}

		/* Do we have a active sensing chapter? */
		if ( systemflags & RTP_MIDI_SJ_FLAG_V ) {
			offset++;
		}

		/* Do we have a sequencer state commands chapter? */
		if ( systemflags & RTP_MIDI_SJ_FLAG_Q ) {
			offset += decode_sj_chapter_q( rtpMidi, packetBuffer, offset );
		}

		/* Do we have a MTC chapter? */
		if ( systemflags & RTP_MIDI_SJ_FLAG_F ) {
			offset += decode_sj_chapter_f( rtpMidi, packetBuffer, offset );
		}


		/* Do we have a Sysex chapter? */
		if ( systemflags & RTP_MIDI_SJ_FLAG_X ) {
			ext_consumed = decode_sj_chapter_x( rtpMidi, packetBuffer, offset, sysjourlen - consumed );
			if ( ext_consumed < 0 ) {
				return ext_consumed;
			}
			offset += ext_consumed;
		}

		/* Make sanity check for consumed data vs. stated length of system journal */
		if ( offset-start_offset != sysjourlen ) {
			return -1;
		}
		return offset-start_offset;
	}

	/*
	 * Here a channel-journal is decoded.
	 */
	static int
	decode_channel_journal(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
	   uint32_t				chanflags;
	   uint16_t				chanjourlen;
	   int				consumed = 0;
	   int				ext_consumed = 0;

	   /* first we need to get the flags & length of this channel-journal */
	   //memcpy(&chanflags, packetBuffer + offset, 3);

	   chanflags = ((uint32_t)*((const uint8_t *)packetBuffer + offset)<<16|  \
	  			   (uint32_t)*((const uint8_t *)packetBuffer + (offset+1))<<8|   \
	  			   (uint32_t)*((const uint8_t *)packetBuffer + (offset+2))<<0);

		chanjourlen = ( chanflags & RTP_MIDI_CJ_MASK_LENGTH ) >> 8;

	#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.print("Chan Flags: ");
		Serial.print(chanflags, HEX);

	   Serial.print("decode_channel_journal - Reported channel length: ");
	   Serial.print(chanjourlen);
	   Serial.print(", Beginning offset: ");
	   Serial.println(offset);
	#endif

			/* take care of length of header */
			offset	 += 3;
			consumed += 3;

			/* Do we have a program change chapter? */
			if ( chanflags & RTP_MIDI_CJ_FLAG_P ) {
				#ifdef APPLEMIDI_DEBUG_VERBOSE
					Serial.println("cj_flag_p: 3");
				#endif

				offset	 += 3;
				consumed += 3;
			}

			/* Do we have a control chapter? */
			if ( chanflags & RTP_MIDI_CJ_FLAG_C ) {
				ext_consumed = decode_cj_chapter_c(rtpMidi, packetBuffer, offset );
	#ifdef APPLEMIDI_DEBUG_VERBOSE
				Serial.print("cj_chapter_c: ");
				Serial.println(ext_consumed);
	#endif

				if ( ext_consumed < 0 ) {
					return ext_consumed;
				}
				consumed += ext_consumed;
				offset	 += ext_consumed;

			}

			/* Do we have a parameter changes? */
			if ( chanflags & RTP_MIDI_CJ_FLAG_M ) {
				ext_consumed = decode_cj_chapter_m(rtpMidi, packetBuffer, offset );
	#ifdef APPLEMIDI_DEBUG_VERBOSE
				Serial.print("cj_chapter_m: ");
				Serial.println(ext_consumed);
	#endif

				if ( ext_consumed < 0 ) {
					//return ext_consumed;
				}
				consumed += ext_consumed;
				offset	 += ext_consumed;
			}

			/* Do we have a pitch-wheel chapter? */
			if ( chanflags & RTP_MIDI_CJ_FLAG_W ) {

				offset++;
				consumed++;

				offset++;
				consumed++;
			}

			/* Do we have a note on/off chapter? */
			if ( chanflags & RTP_MIDI_CJ_FLAG_N ) {
				ext_consumed = decode_cj_chapter_n(rtpMidi, packetBuffer, offset );
	#ifdef APPLEMIDI_DEBUG_VERBOSE
				Serial.print("cj_chapter_n: ");
				Serial.println(ext_consumed);
	#endif

				if ( ext_consumed < 0 ) {
					//return ext_consumed;
				}
				consumed += ext_consumed;
				offset	 += ext_consumed;
			}

			/* Do we have a note command extras chapter? */
			if ( chanflags & RTP_MIDI_CJ_FLAG_E ) {
				ext_consumed = decode_cj_chapter_e(rtpMidi, packetBuffer, offset );
	#ifdef APPLEMIDI_DEBUG_VERBOSE
				Serial.print("cj_chapter_e: ");
				Serial.println(ext_consumed);
	#endif

				if ( ext_consumed < 0 ) {
					//return ext_consumed;
				}
				consumed += ext_consumed;
				offset	 += ext_consumed;
			}

			/* Do we have channel aftertouch chapter? */
			if ( chanflags & RTP_MIDI_CJ_FLAG_T ) {

				offset++;
				consumed++;
			}

			/* Do we have a poly aftertouch chapter? */
			if ( chanflags & RTP_MIDI_CJ_FLAG_A ) {
				ext_consumed = decode_cj_chapter_a(rtpMidi, packetBuffer, offset );
	#ifdef APPLEMIDI_DEBUG_VERBOSE
				Serial.print("cj_chapter_a: ");
				Serial.println(ext_consumed);
	#endif

				if ( ext_consumed < 0 ) {
					//return ext_consumed;
				}
				consumed += ext_consumed;
			}

			/* Make sanity check for consumed data vs. stated length of this channels journal */
			if ( consumed != chanjourlen ) {
	#ifdef APPLEMIDI_DEBUG_VERBOSE
			   Serial.print("Calculated consumption for channel journal: ");
			   Serial.print(consumed);
			 Serial.print(" != Channel Journal Length: ");
			   Serial.println(chanjourlen);
	#endif
				return chanjourlen;
			}

			return consumed;
		}

	/*
	* Here each single MIDI-command is decoded.
	* The Status-octet is read and then the decoding
	* of the individual MIDI-commands is punted to
	* external decoders.
	*/
	static int
	decodemidi(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len, byte *runningstatus, unsigned int *rsoffset )
	{
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decodemidi");
#endif

		int	consumed = 0;
		int	ext_consumed = 0;
		bool using_rs;

		/* extra sanity check */
		if ( !cmd_len ) {
#ifdef APPLEMIDI_DEBUG
Serial.print ("sanity check failed");
#endif
			return -1;
		}

		byte octet = packetBuffer[offset];

		/* midi realtime-data -> one octet -- unlike serial-wired MIDI realtime-commands in RTP-MIDI will
		* not be intermingled with other MIDI-commands, so we handle this case right here and return */
		if ( octet >= 0xf8 ) {
			//proto_item *command_item;
			//proto_tree *command_tree;
			//const gchar *valstr;

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("RealTime");
#endif

			//valstr = val_to_str( octet, rtp_midi_common_status, rtp_midi_unknown_value_hex );
			//command_item = proto_tree_add_text(tree, tvb, offset, 1, "%s", valstr );
			//command_tree = proto_item_add_subtree( command_item, ett_rtp_midi_command);
			//proto_tree_add_item( command_tree, hf_rtp_midi_common_status, tvb, offset, 1, ENC_BIG_ENDIAN );

			//if ( cmd_count ) {
			//	col_add_fstr(pinfo->cinfo, COL_INFO,", %s", valstr );
			//} else {
			//	col_add_str(pinfo->cinfo, COL_INFO, valstr );
			//}

			return 1;
		}

		/* see if this first octet is a status message */
		if ( ( octet & RTP_MIDI_COMMAND_STATUS_FLAG ) == 0 ) {
			/* if we have no running status yet -> error */
			if ( ( ( *runningstatus ) & RTP_MIDI_COMMAND_STATUS_FLAG ) == 0 ) {
				return -1;
			}
			/* our first octet is "virtual" coming from a preceding MIDI-command,
			* so actually we have not really consumed anything yet */
			octet = *runningstatus;
			using_rs = true;
		} else {

			/* We have a "real" status-byte */
			using_rs = false;

			/* Let's see how this octet influences our running-status */
			/* if we have a "normal" MIDI-command then the new status replaces the current running-status */
			if ( octet < 0xf0 ) {
				*rsoffset = offset ;
				*runningstatus = octet;
			}
			else {
				/* system-realtime-commands maintain the current running-status
				* other system-commands clear the running-status, since we
				* already handled realtime, we can reset it here */
				*runningstatus = 0;
			}

			/* lets update our pointers */
			consumed++;
			cmd_len--;
			offset++;
		}

		/* non-system MIDI-commands encode the command in the high nibble and the channel
		* in the low nibble - so we will take care of those cases next */

		if (octet < 0xf0) {
#ifdef APPLEMIDI_DEBUG_VERBOSE
			Serial.print("MIDI command ");
			Serial.println(octet >> 4);
#endif
			switch (octet >> 4) {
			case RTP_MIDI_STATUS_CHANNEL_NOTE_OFF:
				ext_consumed = decode_note_off(rtpMidi, packetBuffer, cmd_count, offset, cmd_len, octet, *rsoffset, using_rs);
				break;
			case RTP_MIDI_STATUS_CHANNEL_NOTE_ON:
				ext_consumed = decode_note_on(rtpMidi, packetBuffer, cmd_count, offset, cmd_len, octet, *rsoffset, using_rs);
				break;
			case RTP_MIDI_STATUS_CHANNEL_POLYPHONIC_KEY_PRESSURE:
				ext_consumed = decode_poly_pressure(rtpMidi, packetBuffer, cmd_count, offset, cmd_len, octet, *rsoffset, using_rs);
				break;

			// If these below calls are uncommented, the ESP8266 crashes when the execution comes here
			// even if the functions are NOT called. Works fine on ARDUINO

			case RTP_MIDI_STATUS_CHANNEL_CONTROL_CHANGE:
				ext_consumed = decode_control_change(rtpMidi, packetBuffer, cmd_count, offset, cmd_len, octet, *rsoffset, using_rs);
				break;
			case RTP_MIDI_STATUS_CHANNEL_PROGRAM_CHANGE:
				ext_consumed = decode_program_change(rtpMidi, packetBuffer, cmd_count, offset, cmd_len, octet, *rsoffset, using_rs);
				break;
			case RTP_MIDI_STATUS_CHANNEL_CHANNEL_PRESSURE:
				ext_consumed = decode_channel_pressure(rtpMidi, packetBuffer, cmd_count, offset, cmd_len, octet, *rsoffset, using_rs);
				break;
			case RTP_MIDI_STATUS_CHANNEL_PITCH_BEND_CHANGE:
				ext_consumed = decode_pitch_bend_change(rtpMidi, packetBuffer, cmd_count, offset, cmd_len, octet, *rsoffset, using_rs);
				break;
			default:
				ext_consumed = -1;
#ifdef APPLEMIDI_DEBUG
				Serial.println("Unknown midi command octet");
#endif
			}

			/* external decoder informed us of error -> pass this through */
			if (ext_consumed < 0) {
#ifdef APPLEMIDI_DEBUG
Serial.print("Midi Consumed < 0. ");
Serial.println(ext_consumed);
#endif
				return ext_consumed;
			}

			return consumed + ext_consumed;
		}

		/* Here we catch the remaining system-common commands */
		switch ( octet ) {
		case RTP_MIDI_STATUS_COMMON_SYSEX_START:
			ext_consumed = decode_sysex_start(rtpMidi, packetBuffer, cmd_count, offset, cmd_len );
			break;
		case RTP_MIDI_STATUS_COMMON_MTC_QUARTER_FRAME:
			ext_consumed = decode_mtc_quarter_frame(rtpMidi, packetBuffer, cmd_count, offset, cmd_len );
			break;
		case RTP_MIDI_STATUS_COMMON_SONG_POSITION_POINTER:
			ext_consumed = decode_song_position_pointer(rtpMidi, packetBuffer, cmd_count, offset, cmd_len );
			break;
		case RTP_MIDI_STATUS_COMMON_SONG_SELECT:
			ext_consumed = decode_song_select(rtpMidi, packetBuffer, cmd_count, offset, cmd_len );
			break;
		case RTP_MIDI_STATUS_COMMON_UNDEFINED_F4:
			ext_consumed = decode_undefined_f4(rtpMidi, packetBuffer, cmd_count, offset, cmd_len );
			break;
		case RTP_MIDI_STATUS_COMMON_UNDEFINED_F5:
			ext_consumed = decode_undefined_f5(rtpMidi, packetBuffer, cmd_count, offset, cmd_len );
			break;
		case RTP_MIDI_STATUS_COMMON_TUNE_REQUEST:
			ext_consumed = decode_tune_request(rtpMidi, packetBuffer, cmd_count, offset, cmd_len );
			break;
		case RTP_MIDI_STATUS_COMMON_SYSEX_END:
			ext_consumed = decode_sysex_end(rtpMidi, packetBuffer, cmd_count, offset, cmd_len );
			break;
		default:
			ext_consumed = -1;
#ifdef APPLEMIDI_DEBUG
			Serial.println("Unknown system command octet");
#endif
			break;
		}

		/* external decoder informed us of error -> pass this through */
		if ( ext_consumed < 0 ) {
#ifdef APPLEMIDI_DEBUG
Serial.print("System Consumed < 0. ");
Serial.println(ext_consumed);
#endif

			return ext_consumed;
		}

		return consumed + ext_consumed;
	}

	/*
	* This decodes the delta-time before a MIDI-command
	*/
	static int
	decodetime(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int cmd_len)
	{
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decodetime");
#endif

		unsigned int consumed = 0;

		/* RTP-MIDI deltatime is "compressed" using only the necessary amount of octets */
		for (int i = 0; i < 4; i++ ) {
			if (!cmd_len) {
				return -1;
			}

			uint8_t octet = packetBuffer[offset + consumed];
			unsigned long deltatime = ( deltatime << 7 ) | ( octet & RTP_MIDI_DELTA_TIME_OCTET_MASK );
			consumed++;

			if ( ( octet & RTP_MIDI_DELTA_TIME_EXTENSION ) == 0 ) {
				break;
			}
		}

		return consumed;
	}

	/*
	* Here a Note-Off command is decoded.
	*/
	static int
	decode_note_off(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len, byte status, unsigned int rsoffset, bool using_rs ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_note_off");
#endif

		//status_str = val_to_str( status >> 4, rtp_midi_channel_status, rtp_midi_unknown_value_hex );

		uint8_t type    = (status >> 4);
		uint8_t channel = (status & RTP_MIDI_CHANNEL_MASK) + 1;

		/* broken: we have no further data */
		if ( !cmd_len ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("no further data");
#endif
			return -1;
		}

		uint8_t note = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( note & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command: note_off");
#endif
			return 1;
		}

		//note_str = val_to_str( note, rtp_midi_note_values, rtp_midi_unknown_value_dec );

		/* broken: we have only one further octet */
		if ( cmd_len < 2 ) {
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("not enough q");
#endif
			return 1;
		}

		uint8_t velocity = packetBuffer[offset + 1];

		/* seems to be an aborted MIDI-command */
		if ( velocity & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command 2: note_off");
#endif

			// Aborted NoteOff packets might be trying to turn the note off.
			// We should do this manually just in case
			rtpMidi->OnNoteOff(NULL, channel, note, 0);

			return 1;
		}


		if ( using_rs ) {
		} else {
		}

		if (rtpMidi->PassesFilter(NULL, type, channel))
			rtpMidi->OnNoteOff(NULL, channel, note, velocity);

		return 2;
	}

	/*
	* Here a Note-On command is decoded.
	*/
	static int
	decode_note_on(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len, uint8_t status, unsigned int rsoffset, bool using_rs )
	{
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_note_on");
#endif

		uint8_t type    = (status >> 4);
		uint8_t channel = (status & RTP_MIDI_CHANNEL_MASK) + 1;

		/* broken: we have no further data */
		if ( !cmd_len ) {
			/* this should never happen! */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("!cmd_len");
#endif
			return -1;
		}

		uint8_t note = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( note & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			/* this should never happethis should never happen */
			if ( using_rs ) {
			} else {
			}
			return -1;
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command: note_on");
#endif
		}

		//note_str = val_to_str( note, rtp_midi_note_values, rtp_midi_unknown_value_dec );

		/* broken: we have only one further octet */
		if ( cmd_len < 2 ) {
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("not enough w");
#endif
			return -1;
		}

		uint8_t velocity = packetBuffer[offset + 1];

		/* seems to be an aborted MIDI-command */
		if ( velocity & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command 2: note_on");
#endif
			// Aborted NoteOn packets might be trying to turn the note off.
			// We should do this manually just in case
			// rtpMidi->OnNoteOff(NULL, channel, note, 0);

			return 0;
		}

		if (rtpMidi->PassesFilter(NULL, type, channel)) {
			/* special case velocity=0 for Note-On means Note-Off (to preserve running-status!) */
			if (velocity == 0) {
				rtpMidi->OnNoteOff(NULL, channel, note, velocity);
			} else {
				rtpMidi->OnNoteOn(NULL, channel, note, velocity);
			}
		}

		return 2;
	}

	/*
	* Here polyphonic aftertouch is decoded.
	*/
	static int
	decode_poly_pressure(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len, byte status, unsigned int rsoffset, bool using_rs ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_poly_pressure");
#endif

		uint8_t type    = (status >> 4);
		uint8_t channel = (status & RTP_MIDI_CHANNEL_MASK) + 1;

		/* broken: we have no further data */
		if ( !cmd_len ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("no further data");
#endif
			return -1;
		}

		uint8_t note = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( note & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command: poly_pressure");
#endif
			return 1;
		}

		//note_str = val_to_str( note, rtp_midi_note_values, rtp_midi_unknown_value_dec );

		/* broken: we have only one further octet */
		if ( cmd_len < 2 ) {
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("not enough e");
#endif
			return cmd_len;
		}

		uint8_t pressure = packetBuffer[offset + 1];

		/* seems to be an aborted MIDI-command */
		if ( pressure  & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command: poly_pressure");
#endif
			return 1;
		}


		if ( using_rs ) {
		} else {
		}

		if (rtpMidi->PassesFilter(NULL, type, channel))
			rtpMidi->OnPolyPressure(NULL, channel, note, pressure);

		return 2;
	}

	/*
	* Here channel aftertouch is decoded.
	*/
	static int
	decode_channel_pressure(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len, byte status, unsigned int rsoffset, bool using_rs ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_channel_pressure");
#endif

		uint8_t type    = (status >> 4);
		uint8_t channel = (status & RTP_MIDI_CHANNEL_MASK) + 1;

		/* broken: we have no further data */
		if ( !cmd_len ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("no further data");
#endif
			return -1;
		}

		uint8_t pressure = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( pressure & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("aborted MIDI-command: channel_pressure");
#endif
			return 1;
		}


		if ( using_rs ) {
		} else {
		}

		//if ( cmd_count ) {
		//	col_append_fstr(pinfo->cinfo, COL_INFO,", %s (c=%d, p=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, program );
		//} else {
		//	col_append_fstr(pinfo->cinfo, COL_INFO, "%s (c=%d, p=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, program );
		//}
		if (rtpMidi->PassesFilter(NULL, type, channel))
			rtpMidi->OnChannelPressure(NULL, channel, pressure);

		return 1;
	}

	/*
	* Here pitch-bend is decoded.
	*/
	static int
	decode_pitch_bend_change(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len, byte status, unsigned int rsoffset, bool using_rs ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_pitch_bend_change");
#endif

		uint8_t type    = (status >> 4);
		uint8_t channel = (status & RTP_MIDI_CHANNEL_MASK) + 1;

		/* broken: we have no further data */
		if ( !cmd_len ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("no further data");
#endif
			return -1;
		}

		uint8_t octet1 = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( octet1 & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("aborted MIDI-command: pitch_bend_change");
#endif
			return cmd_len;
		}

		/* broken: we have only one further octet */
		if ( cmd_len < 2 ) {
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("not enough r");
#endif
			return cmd_len;
		}

		uint8_t octet2 = packetBuffer[offset + 1];

		/* seems to be an aborted MIDI-command */
		if ( octet2 & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command 2: pitch_bend_change");
#endif
			return cmd_len;
		}

		int pitch = ( octet1 << 7 ) | octet2;

		if ( using_rs ) {
		} else {
		}

		//if ( cmd_count ) {
		//	col_append_fstr(pinfo->cinfo, COL_INFO,", %s (c=%d, pb=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, pitch );
		//} else {
		//	col_append_fstr(pinfo->cinfo, COL_INFO, "%s (c=%d, pb=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, pitch );
		//}

		if (rtpMidi->PassesFilter(NULL, type, channel))
			rtpMidi->OnPitchBendChange(NULL, channel, pitch);

		return 2;

	}

	/*
	* Here program_change is decoded.
	*/
	static int
	decode_program_change(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len, byte status, unsigned int rsoffset, bool using_rs ) {

#ifdef APPLEMIDI_DEBUG
Serial.println("decode_program_change");
#endif

		uint8_t type    = (status >> 4);
		uint8_t channel = (status & RTP_MIDI_CHANNEL_MASK) + 1;

		/* broken: we have no further data */
		if ( !cmd_len ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("no further data");
#endif
			return -1;
		}

		uint8_t program = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( program & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command: program_change");
#endif
			return cmd_len;
		}


		if ( using_rs ) {
		} else {
		}

		//if ( cmd_count ) {
		//	col_append_fstr(pinfo->cinfo, COL_INFO,", %s (c=%d, p=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, program );
		//} else {
		//	col_append_fstr(pinfo->cinfo, COL_INFO, "%s (c=%d, p=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, program );
		//}
		if (rtpMidi->PassesFilter(NULL, type, channel))
			rtpMidi->OnProgramChange(NULL, channel, program);


		return 1;
	}

	/*
	* Here control change is decoded.
	*/
	static int
	decode_control_change(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len, byte status, unsigned int rsoffset, bool using_rs ) {

#ifdef APPLEMIDI_DEBUG
Serial.println("decode_control_change");
#endif

		uint8_t type    = (status >> 4);
		uint8_t channel = (status & RTP_MIDI_CHANNEL_MASK) + 1;

		/* broken: we have no further data */
		if ( !cmd_len ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("no further data");
#endif
			return -1;
		}

		uint8_t controller = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( controller & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			/* this case should never happen */
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command: control_change");
#endif
			return cmd_len;
		}

		//note_str = val_to_str( note, rtp_midi_note_values, rtp_midi_unknown_value_dec );

		/* broken: we have only one further octet */
		if ( cmd_len < 2 ) {
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("not enough t");
#endif
			return cmd_len;
		}

		uint8_t value = packetBuffer[offset + 1];

		/* seems to be an aborted MIDI-command */
		if ( value  & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			if ( using_rs ) {
			} else {
			}
#ifdef APPLEMIDI_DEBUG
Serial.println("aborted MIDI-command 2: control_change");
#endif
			return cmd_len;
		}


		if ( using_rs ) {
		} else {
		}

		if (rtpMidi->PassesFilter(NULL, type, channel))
			rtpMidi->OnControlChange(NULL, channel, controller, value);

		return 2;

	}

	/*
	* Here a Sysex-Common Non-Realtime Sample Dump Header command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_sd_hdr( unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_sysex_common_nrt_sd_hdr");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime Sample Dump Packet command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_sd_packet(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_sysex_common_nrt_sd_packet");
#endif

		return 1;
	}


	/*
	* Here a Sysex-Common Non-Realtime Sample Dump Request command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_sd_req(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_sd_req");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime Sample Dump Extension command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_sd_ext(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_sd_ext");
#endif

		return 1;
	}


	/*
	* Here a Sysex-Common Non-Realtime General Information command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_gi(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_gi");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime File Dump command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_fd(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_fd");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common (Non-)Realtime MIDI Tuning Standard command is decoded.
	* As the code-points do not overlap, both RT and NRT are decoded here...
	*/
	static unsigned int
	decode_sysex_common_tuning(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_tuning");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime General MIDI command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_gm(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_gm");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime Downloadable Sounds command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_dls(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_dls");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime End Of File command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_eof(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_eof");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime Wait command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_wait(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_wait");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime Cancel command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_cancel(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_cancel");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime NAK command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_nak(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_nak");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime ACK command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt_ack(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_ack");
#endif

		return 1;
	}

	/*
	* here a sysex-common non-realtime midi time code cueing command is decoded.
	* as the codepoints are the same, we decode both realtime and non-realtime here.
	*/
	static unsigned int
	decode_sysex_common_nrt_mtc(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt_mtc");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Realtime MIDI Time Code Cueing command is decoded.
	* As the codepoints are the same, we decode both realtime and non-realtime here.
	*/
	static unsigned int
	decode_sysex_common_rt_mtc_cue(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_rt_mtc_cue");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Non-Realtime command is decoded.
	*/
	static unsigned int
	decode_sysex_common_nrt(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_nrt");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Realtime MIDI Time Code command is decoded.
	*/
	static unsigned int
	decode_sysex_common_rt_mtc(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_rt_mtc");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Realtime MIDI Show Control command is decoded.
	*/
	static unsigned int
	decode_sysex_common_rt_sc(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_rt_sc");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Realtime Notation Information command is decoded.
	*/
	static unsigned int
	decode_sysex_common_rt_ni(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_rt_ni");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Realtime Device Control command is decoded.
	*/
	static unsigned int
	decode_sysex_common_rt_dc(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_rt_dc");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Realtime MIDI Machine Control command is decoded.
	*/
	static unsigned int
	decode_sysex_common_rt_mmc_command(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_rt_mmc_command");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Realtime MIDI Machine Control response is decoded.
	*/
	static unsigned int
	decode_sysex_common_rt_mmc_response(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_rt_mmc_response");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Realtime command is decoded.
	*/
	static unsigned int
	decode_sysex_common_rt(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_common_rt");
#endif

		return 1;
	}

	/*
	* Here a Sysex-Common Educational command is decoded.
	* According to the MIDI-specification, this should never be found "in the wild".
	* We don't know what this data encodes, so we just dump it.
	*/
	static unsigned int
	decode_sysex_common_educational(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_sysex_common_educational");
#endif

		int		 consumed	= 0;

		if ( data_len < 1 )
			return consumed;

		/* We consumed everything */
		return data_len;
	}

	/*
	* Here a Sysex-Common Manufacturer command is decoded.
	* We don't know what this data encodes, so we just dump it.
	*/
	static unsigned int
	decode_sysex_common_manufacturer(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int data_len, unsigned int manu_code) {

		int		 consumed	= 0;

		if ( data_len < 1 )
			return consumed;

		/* Instead of dumping, at this point we could implement to start manufacturer-specific decoding
		 * of the sysex-data...
		 */

		/* We consumed everything */
		return data_len;
	}


	/*
	* Here a Sysex-Start command is decoded.
	*/
	static unsigned int
	decode_sysex_start(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_sysex_start");
#endif

		int		 consumed	= 0;
		int		 data_len;
		int		 ext_consumed	= 0;

		/* we need to parse "away" data until the next command */
		while ( cmd_len ) {

			uint8_t octet = packetBuffer[offset + consumed];
			consumed++;

			/*
			 * lets check if we have a "normal" end -
			 * if so, the last status-byte is consumed
			 * as it belongs to the message
			 */
			if ( octet == RTP_MIDI_STATUS_COMMON_SYSEX_END ) {
				//status_str = rtp_midi_common_status_sysex_segment_complete;
			} else if ( octet == RTP_MIDI_STATUS_COMMON_SYSEX_START ) {
				//status_str = rtp_midi_common_status_sysex_segment_start;
			} else if ( octet == RTP_MIDI_STATUS_COMMON_UNDEFINED_F4 ) {
				//status_str = rtp_midi_common_status_sysex_cancel;
			}

			/* Is this command through? */
			if ( octet & RTP_MIDI_COMMAND_STATUS_FLAG ) {
				break;
			}
		}

		/* the unknown data we have does not include the trailing status-command */
		data_len = consumed - 1;

		/* lets see if we have enough data for the sysex-id */
		if ( data_len > 1 ) {

			uint16_t manufacturer = packetBuffer[offset];

			uint8_t manu_short = packetBuffer[offset];
			offset++;
			data_len--;

			switch( manu_short ) {
				case RTP_MIDI_MANU_SHORT_NON_REALTIME_UNIVERSAL:
					ext_consumed = decode_sysex_common_nrt( rtpMidi, packetBuffer, offset, data_len );
					break;
				case RTP_MIDI_MANU_SHORT_REALTIME_UNIVERSAL:
					ext_consumed = decode_sysex_common_rt( rtpMidi, packetBuffer, offset, data_len );
					break;
				case RTP_MIDI_MANU_SHORT_EDUCATIONAL_USE:
					ext_consumed = decode_sysex_common_educational( rtpMidi, packetBuffer, offset, data_len );
					break;
				case RTP_MIDI_MANU_SHORT_ISLONG:
					/* lets see if we have enough data to decode a long sysex-id and if we have a long id at all */
					if ( data_len > 2 ) {
						//manufacturer = tvb_get_ntohs( tvb, offset );
						offset	     +=	2 ;
						data_len     -= 2;
						ext_consumed  = decode_sysex_common_manufacturer( rtpMidi, packetBuffer, offset, data_len, manufacturer );
					}  else {
						ext_consumed  = -1;
					}
					break;
				default:
					ext_consumed = decode_sysex_common_manufacturer( rtpMidi, packetBuffer, offset, data_len, manufacturer );
					break;
			}
		}

		if ( ext_consumed < 0 ) {
			return -1;
		}

		/* set our pointers correct to move past already decoded data */
		offset += ext_consumed;

		//proto_tree_add_item( command_tree, hf_rtp_midi_common_status, tvb, offset, 1, ENC_BIG_ENDIAN );

		//if ( cmd_count ) {
		//	col_append_fstr(pinfo->cinfo, COL_INFO,", %s", status_str );
		//} else {
		//	col_append_str(pinfo->cinfo, COL_INFO, status_str );
		//}

		// TODO: what to do here???
		Serial.println("decode_sysex_start");

		return consumed;

	}

	/*
	* Here the MIDI-Time-Code (MTC) Quarter Frame command is decoded.
	*/
	static int
	decode_mtc_quarter_frame(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_mtc_quarter_frame");
#endif

		//const gchar	*status_str;
		//proto_item	*command_item;
		//proto_tree	*command_tree;

		//status_str = val_to_str( RTP_MIDI_STATUS_COMMON_MTC_QUARTER_FRAME, rtp_midi_common_status, rtp_midi_unknown_value_hex );

		/* broken: we have no further data */
		if ( !cmd_len ) {
			//command_item = proto_tree_add_text( tree, tvb, offset - 1, 1, "TRUNCATED: %s ", status_str );
			//command_tree = proto_item_add_subtree( command_item, ett_rtp_midi_command );
			//proto_tree_add_item( command_tree, hf_rtp_midi_common_status, tvb, offset - 1, 1, ENC_BIG_ENDIAN );
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("no further data");
#endif
		return -1;
		}

		byte value = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( value & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			//command_item = proto_tree_add_text( tree, tvb, offset - 1, 1, "ABORTED: %s", status_str );
			//command_tree = proto_item_add_subtree( command_item, ett_rtp_midi_command );
			//proto_tree_add_item( command_tree, hf_rtp_midi_common_status, tvb, offset - 1, 1, ENC_BIG_ENDIAN );
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("aborted MIDI-command: mtc_quarter_frame");
#endif
			return -1;
		}


		if ( cmd_count ) {
			//col_append_fstr(pinfo->cinfo, COL_INFO, ", %s", status_str );
		} else {
			//col_append_str(pinfo->cinfo, COL_INFO, status_str );
		}

//		if (rtpMidi->PassesFilter(NULL, type, channel))
			rtpMidi->OnTimeCodeQuarterFrame(NULL, value);

		return 1;
	}

	/*
	* Here the Song Position Pointer command is decoded.
	*/
	static int
	decode_song_position_pointer(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_song_position_pointer");
#endif

		/* broken: we have no further data */
		if ( !cmd_len ) {
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("no further data");
#endif
			return -1;
		}

		uint8_t octet1 = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( octet1 & RTP_MIDI_COMMAND_STATUS_FLAG ) {
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("aborted MIDI-command: song_position_pointer");
#endif
			return -1;
		}

		/* broken: we have only one further octet */
		if ( cmd_len < 2 ) {
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("not enough y");
#endif
			return -1;
		}

		uint8_t octet2 = packetBuffer[offset + 1];

		/* seems to be an aborted MIDI-command */
		if ( octet2 & RTP_MIDI_COMMAND_STATUS_FLAG ) {
			/* this case should never happen */
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("aborted MIDI-command 2: song_position_pointer");
#endif
			return -1;
		}

		int position = ( octet1 << 7 ) | octet2;

		//if ( cmd_count ) {
		//	col_append_fstr(pinfo->cinfo, COL_INFO,", %s (c=%d, pb=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, pitch );
		//} else {
		//	col_append_fstr(pinfo->cinfo, COL_INFO, "%s (c=%d, pb=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, pitch );
		//}

		rtpMidi->OnSongPosition(NULL, position);

		return 2;
	}

	/*
	* Here a Song-Select command is decoded.
	*/
	static int
	decode_song_select(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("decode_song_select");
#endif

		/* broken: we have no further data */
		if ( !cmd_len ) {
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("no further data");
#endif
			return -1;
		}

		uint8_t song_nr = packetBuffer[offset];

		/* seems to be an aborted MIDI-command */
		if ( song_nr & RTP_MIDI_COMMAND_STATUS_FLAG ) {
#ifdef APPLEMIDI_DEBUG_VERBOSE
Serial.println("aborted MIDI-command: decode_song_select");
#endif
			return -1;
		}

		//if ( cmd_count ) {
		//	col_append_fstr(pinfo->cinfo, COL_INFO,", %s (c=%d, pb=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, pitch );
		//} else {
		//	col_append_fstr(pinfo->cinfo, COL_INFO, "%s (c=%d, pb=%d)", status_str, ( status & RTP_MIDI_CHANNEL_MASK ) + 1, pitch );
		//}

		rtpMidi->OnSongSelect(NULL, song_nr);

		return 1;
	}

	/*
	* Here the undefined common-command 0xf4 is decoded.
	*/
	static int
	decode_undefined_f4(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_undefined_f4");
#endif

		return 1;
	}

	/*
	* Here the undefined common-command 0xf5 is decoded.
	*/
	static int
	decode_undefined_f5(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_undefined_f5");
#endif

		return 1;
	}

	/*
	* Here a Tune-Request command is decoded.
	*/
	static int
	decode_tune_request(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_tune_request");
#endif

		rtpMidi->OnTuneRequest(NULL);

		return 0;
	}

	/*
	* Here a Sysex-End command is decoded - in RTP-MIDI this has a special semantic, it either starts a segmented Sysex-frame or a Sysex-Cancel
	*/
	static int
	decode_sysex_end(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int cmd_count, unsigned int offset, unsigned int cmd_len ) {

#ifdef APPLEMIDI_DEBUG_VERBOSE
		Serial.println("decode_sysex_end");
#endif

		int consumed = 0;

		/* we need to parse "away" data until the next command */
		while ( cmd_len ) {

			uint8_t octet = packetBuffer[offset + consumed];
			consumed++;

			/*
			 * lets check if we have a "normal" end -
			 * if so, the last status-byte is consumed
			 * as it belongs to the message
			 */
			if ( octet == RTP_MIDI_STATUS_COMMON_SYSEX_END ) {
				//status_str = rtp_midi_common_status_sysex_segment_end;
			} else if ( octet == RTP_MIDI_STATUS_COMMON_SYSEX_START ) {
				//status_str = rtp_midi_common_status_sysex_segment;
			} else if ( octet == RTP_MIDI_STATUS_COMMON_UNDEFINED_F4 ) {
				//status_str = rtp_midi_common_status_sysex_cancel;
			}

			/* Is this command through? */
			if ( octet & RTP_MIDI_COMMAND_STATUS_FLAG ) {
				break;
			}
		}

		return consumed;
	}

	/*
	 * Here the chapter Q of the channel-journal is decoded.
	 */
	static int
	decode_sj_chapter_q(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset ) {
		uint8_t				header;
		unsigned int start_offset = offset;
		int				len = 1;

		/* first we need to get the flags of this chapter */
		header = packetBuffer[offset];

		if ( header & RTP_MIDI_SJ_CHAPTER_Q_FLAG_C ) {
			len += 2;
		}
		if ( header & RTP_MIDI_SJ_CHAPTER_Q_FLAG_T ) {
			len += 3;
		}

		if ( header & RTP_MIDI_SJ_CHAPTER_Q_FLAG_C ) {
			offset	 += 3;
		} else {
			offset++;
		}

		if ( header & RTP_MIDI_SJ_CHAPTER_Q_FLAG_T ) {
			offset += 3;
		}

		return offset-start_offset;
	}

	/*
	 * Here the chapter F of the channel-journal is decoded.
	 */
	static int
	decode_sj_chapter_f(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
		uint8_t				header;
		unsigned int start_offset = offset;
		int				len = 1;

		/* first we need to get the flags of this chapter */
		header = packetBuffer[offset];

		if ( header & RTP_MIDI_SJ_CHAPTER_F_FLAG_C ) {
			len += 4;
		}
		if ( header & RTP_MIDI_SJ_CHAPTER_F_FLAG_P ) {
			len += 4;
		}

		offset++;

		if ( header & RTP_MIDI_SJ_CHAPTER_F_FLAG_C ) {
			offset	 += 4;
		}

		if ( header & RTP_MIDI_SJ_CHAPTER_F_FLAG_P ) {
			offset += 4;
		}

		return offset-start_offset;
	}

	/*
	 * Here the chapter X of the channel-journal is decoded.
	 */
	static int
	decode_sj_chapter_x(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset, unsigned int max_length) {
		uint8_t				header;
		uint8_t				octet;
		unsigned int			consumed = 0;
		unsigned int			cmdlen   = 0;
		unsigned int			i;

		/* first we need to get the flags of this chapter */
		header = packetBuffer[offset];

		consumed++;
		offset++;

		if ( header & RTP_MIDI_SJ_CHAPTER_X_FLAG_T ) {
			consumed++;
			offset++;
		}

		if ( header & RTP_MIDI_SJ_CHAPTER_X_FLAG_C ) {
			consumed++;
			offset++;
		}

		if ( header & RTP_MIDI_SJ_CHAPTER_X_FLAG_F ) {
			unsigned int field    = 0;
			unsigned int fieldlen = 0;

			/* FIRST is "compressed" using only the necessary amount of octets, like delta-time */
			for ( i=0; i < 4; i++ ) {
				/* do we still fit in the dissected packet & in the length restriction of this chapter? */
				if ( ( !( consumed >= max_length ) ) || ( !packetBuffer[offset + fieldlen + 1] ) ) {
					return -1;
				}

				octet = packetBuffer[offset + fieldlen];
				field = ( field << 7 ) | ( octet & RTP_MIDI_DELTA_TIME_OCTET_MASK );
				fieldlen++;

				if ( ( octet & RTP_MIDI_DELTA_TIME_EXTENSION ) == 0 ) {
					break;
				}
			}

			consumed += fieldlen;
			offset	 += fieldlen;
		}

		/* XXX: 'cmdlen' in the following is always 0 (since initialized to 0 above) ??? */
		if ( header & RTP_MIDI_SJ_CHAPTER_X_FLAG_D ) {
			while ( consumed < max_length ) {
				octet = packetBuffer[offset + cmdlen];
				if ( octet & 0x80 ) {
					offset += cmdlen;
					cmdlen	= 0;
				}
				consumed += 1;
			}
			/* unfinished command still to put into tree */
			if ( cmdlen ) {
				offset += cmdlen;
			}
		}

		/* this should not ever enter - we still have data, but flag d was apparently not set...  */
		if ( consumed < max_length ) {
			consumed = max_length;
		}

		return consumed;
	}

   /*
    * Here the chapter D of the channel-journal is decoded.
    */
   static int
	decode_sj_chapter_d(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
      int				header;
      unsigned int start_offset = offset;
      int				ext_consumed;

      /* first we need to get the flags of this chapter */
      header = packetBuffer[offset];

      /* done with header */
      offset++;

      /* do we have Reset field? */
      if ( header & RTP_MIDI_SJ_CHAPTER_D_FLAG_B ) {
         offset++;
      }

      /* do we have Tune request field? */
      if ( header & RTP_MIDI_SJ_CHAPTER_D_FLAG_G ) {
         offset++;
      }

      /* do we have Song select field? */
      if ( header & RTP_MIDI_SJ_CHAPTER_D_FLAG_H ) {
         offset++;
      }

      /* do we have 0xF4 field? */
      if ( header & RTP_MIDI_SJ_CHAPTER_D_FLAG_J ) {
         ext_consumed = decode_sj_chapter_d_f4(rtpMidi, packetBuffer, offset);
         if ( ext_consumed < 0 ) {
            return ext_consumed;
         }
         offset	 += ext_consumed;
      }

      /* do we have 0xF5 field? */
      if ( header & RTP_MIDI_SJ_CHAPTER_D_FLAG_K ) {
         ext_consumed = decode_sj_chapter_d_f5(rtpMidi, packetBuffer, offset);
         if ( ext_consumed < 0 ) {
            return ext_consumed;
         }
         offset	 += ext_consumed;
      }

      /* do we have 0xF9 field? */
      if ( header & RTP_MIDI_SJ_CHAPTER_D_FLAG_Y ) {
         ext_consumed = decode_sj_chapter_d_f9(rtpMidi, packetBuffer, offset);
         if ( ext_consumed < 0 ) {
            return ext_consumed;
         }
         offset	 += ext_consumed;
      }

      /* do we have 0xFD field? */
      if ( header & RTP_MIDI_SJ_CHAPTER_D_FLAG_Z ) {
         ext_consumed = decode_sj_chapter_d_fd(rtpMidi, packetBuffer, offset);
         if ( ext_consumed < 0 ) {
            return ext_consumed;
         }
         offset += ext_consumed;
      }

      /* now we know the complete length and set it. */
      return offset-start_offset;
   }

	/*
	* Here the chapter D F4-field of the system-journal is decoded.
	*/
	static int
	decode_sj_chapter_d_f4(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
      int start_offset = offset;
      uint16_t		 f4flags;
      uint16_t		 f4length;

      /* Get flags & length */
      f4flags = packetBuffer[offset];
      f4length = f4flags & RTP_MIDI_SJ_CHAPTER_D_SYSCOM_MASK_LENGTH;

      offset	 += 2;
      f4length -= 2;

      if ( f4flags & RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_C ) {
         offset++;
         f4length--;
      }

      if ( f4flags & RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_V ) {
         int valuelen = 0;
         uint8_t octet;

         /* variable length field - ends with an octet with MSB set */
         for (;;) {
            octet = packetBuffer[offset+valuelen];
            valuelen++;
            if ( octet & 0x80 ) {
               break;
            }
         }
         offset	 += valuelen;
         f4length -= valuelen;
      }

      if ( f4flags & RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_L ) {
         offset	 += f4length;
      }

      /* if we still have data, the length-field was incorrect we dump the data here and abort! */
      if ( f4length > 0 ) {
         offset += f4length;
         /* must be a protocol error - since we have a length, we can recover...*/
      }

      return offset-start_offset;
   }

	static int
	decode_sj_chapter_d_f5(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
	unsigned int start_offset = offset;
	uint16_t		 f5flags;
	uint16_t		 f5length;

	/* Get flags & length */
	f5flags = packetBuffer[offset];
	f5length = f5flags & RTP_MIDI_SJ_CHAPTER_D_SYSCOM_MASK_LENGTH;

	offset	 += 2;
	f5length -= 2;

	if ( f5flags & RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_C ) {
		offset++;
		f5length--;
	}

	if ( f5flags & RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_V ) {

		int valuelen = 0;
		uint8_t octet;

		/* variable length field - ends with an octet with MSB set */
		for (;;) {
			octet = packetBuffer[offset+valuelen];
			valuelen++;
			if ( octet & 0x80 ) {
				break;
			}
		}

		offset	 += valuelen;
		f5length -= valuelen;
	}

	if ( f5flags & RTP_MIDI_SJ_CHAPTER_D_SYSCOM_FLAG_L ) {
		offset	 += f5length;
		f5length = 0;
	}

	/* if we still have data, we dump it here - see above! */
	if ( f5length > 0 ) {
		offset += f5length;
		/* must be a protocol error - since we have a length, we can recover...*/
	}

	return offset-start_offset;
}

	/*
	 * Here the chapter D F9-field of the system-journal is decoded.
	 */
	static int
	decode_sj_chapter_d_f9(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
		unsigned int start_offset = offset;
		uint8_t		 f9flags;
		uint8_t		 f9length;

		/* Get flags & length */
		f9flags = packetBuffer[offset];
		f9length = f9flags & RTP_MIDI_SJ_CHAPTER_D_SYSREAL_MASK_LENGTH;

		offset++;
		f9length--;

		if ( f9flags & RTP_MIDI_SJ_CHAPTER_D_SYSREAL_FLAG_C ) {
			offset++;
			f9length--;
		}

		if ( f9flags & RTP_MIDI_SJ_CHAPTER_D_SYSREAL_FLAG_L ) {
			offset	 += f9length;
			f9length = 0;
		}

		/* if we still have data, the length-field was incorrect we dump the data here and abort! */

		if ( f9length > 0 ) {
			offset += f9length;
			/* must be a protocol error - since we have a length, we can recover...*/
		}

		return offset-start_offset;
	}

	/*
	 * Here the chapter D FD-field of the system-journal is decoded.
	 */
	static int
	decode_sj_chapter_d_fd(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
		unsigned int start_offset = offset;
		uint8_t		 fdflags;
		uint8_t		 fdlength;

		/* Get flags & length */
		fdflags  = packetBuffer[offset];
		fdlength = fdflags & RTP_MIDI_SJ_CHAPTER_D_SYSREAL_MASK_LENGTH;

		offset++;
		fdlength--;

		if ( fdflags & RTP_MIDI_SJ_CHAPTER_D_SYSREAL_FLAG_C ) {
			offset++;
			fdlength--;
		}

		if ( fdflags & RTP_MIDI_SJ_CHAPTER_D_SYSREAL_FLAG_L ) {
			offset	 += fdlength;
			fdlength = 0;
		}

		/* if we still have data, the length-field was incorrect we dump the data here and abort! */

		if ( fdlength > 0 ) {
			offset += fdlength;
			/* must be a protocol error - since we have a length, we can recover...*/
		}

		return offset-start_offset;
	}

	/*
	 * Here the chapter c of the channel-journal is decoded.
	 */
	static int
	decode_cj_chapter_c(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
		unsigned int start_offset = offset;
		uint8_t				 octet;
		int				 count;
		int				 i;

		octet = packetBuffer[offset];
		count = octet & 0x7f;

		/* count encoded is n+1 */
		count++;

		offset++;

		for ( i = 0; i < count; i++ ) {
			offset++;
			octet = packetBuffer[offset];
			offset++;
		}

		return offset-start_offset;
	}

	/*
	 * Here the chapter m of the channel-journal is decoded, possibly the most complex part of the RTP-MIDI stuff ;-)
	 */
	static int
	decode_cj_chapter_m(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
		uint16_t				header;
		uint8_t				logitemheader = 0;
		int				length;
		int				logitemhdrlen;
		int				logitemlen;
		boolean			no_pnum_msb;
		unsigned int start_offset = offset;

		/* first we need to get the flags & length of this chapter */
		header = packetBuffer[offset];
		length = header & RTP_MIDI_CJ_CHAPTER_M_MASK_LENGTH;
		/* take of length of header */
		length -= 2;

		/* done with header */
		offset	 += 2;

		/* do we have the pending field? */
		if ( header & 0x4000 ) {
			offset++;
		}

		/*
		 * lets find out if we need to decode the pnum_msb:
		 * if Z = 1 and either U = 1 or W = 1 we don't
		 */
		no_pnum_msb = ( header & 0x0400 ) && ( ( header & 0x0800 ) || ( header & 0x1000 ) );
		logitemhdrlen = no_pnum_msb ? 2 : 3;

		/* lets step through the loglist */
		while ( length > 0 ) {
			if ( no_pnum_msb ) {
				logitemheader = packetBuffer[offset + 1];
			} else {
				logitemheader = packetBuffer[offset + 2];
			}

			logitemlen = logitemhdrlen;

			/* do we have a msb field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_J ) {
				logitemlen++;
			}

			/* do we have a lsb field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_K ) {
				logitemlen++;
			}

			/* do we have an a-button field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_L ) {
				logitemlen +=2;
			}

			/* do we have a c-button field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_M ) {
				logitemlen +=2;
			}

			/* do we have a count field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_N ) {
				logitemlen++;
			}

			offset++;
			length--;

			if ( !no_pnum_msb ) {
				offset++;
				length--;
			}

			offset++;
			length--;

			/* do we have a entry-msb field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_J ) {
				offset++;
				length--;
			}

			/* do we have a entry-lsb field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_K ) {
				offset++;
				length--;
			}

			/* do we have an a-button field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_L ) {
				offset	 += 2;
				length	 -= 2;
			}

			/* do we have a c-button field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_M ) {
				offset	 += 2;
				length	 -= 2;
			}

			/* do we have a count field? */
			if ( logitemheader & RTP_MIDI_CJ_CHAPTER_M_FLAG_N ) {
				offset++;
				length--;
			}
		}

		return offset-start_offset;
	}


	/*
	 * Here the chapter n of the channel-journal is decoded.
	 */
	static int
	decode_cj_chapter_n(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
		unsigned int start_offset = offset;
		uint16_t				 header;
		//uint8_t				 note;
		//uint8_t				 velocity;
		int				 log_count;
		int				 octet_count;
		int				 low;
		int				 high;
		int				 i;

		/* first we need to get the flags & length of this chapter */
		header = packetBuffer[offset];
		log_count = ( header & RTP_MIDI_CJ_CHAPTER_N_MASK_LENGTH ) >> 8;
		low = ( header & RTP_MIDI_CJ_CHAPTER_N_MASK_LOW ) >> 4;
		high = header & RTP_MIDI_CJ_CHAPTER_N_MASK_HIGH;

		/* how many offbits octets do we have? */
		if ( low <= high ) {
			octet_count = high - low + 1;
		} else if ( ( low == 15 ) && ( high == 0 ) ) {
			octet_count = 0;
		} else if ( ( low == 15 ) && ( high == 1 ) ) {
			octet_count = 0;
		} else {
			return -1;
		}

		/* special case -> no offbit octets, but 128 note-logs */
		if ( ( log_count == 127 ) && ( low == 15) && ( high == 0 ) ) {
			log_count++;
		}

		offset	 += 2;

		if ( log_count > 0 ) {
			for ( i = 0; i < log_count; i++ ) {
				offset++;
				offset++;
			}
		}

		if ( octet_count > 0 ) {
			for ( i = 0; i < octet_count; i++ ) {
				offset++;
			}
		}

		return offset-start_offset;
	}


	/*
	 * Here the chapter e of the channel-journal is decoded.
	 */
	static int
	decode_cj_chapter_e(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
		unsigned int start_offset = offset;
		uint8_t				 header;
		int				 log_count;
		int				 i;

		/* first we need to get the flags & length of this chapter */
		header = packetBuffer[offset];
		log_count = header & RTP_MIDI_CJ_CHAPTER_E_MASK_LENGTH;

		/* count is encoded n+1 */
		log_count++;
		offset++;

		for ( i = 0; i < log_count; i++ ) {
			offset++;
			offset++;
		}

		return offset-start_offset;
	}

	/*
	 * Here the chapter a of the channel-journal is decoded.
	 */
	static int
	decode_cj_chapter_a(IAppleMidi* rtpMidi, unsigned char* packetBuffer, unsigned int offset) {
		unsigned int start_offset = offset;
		uint8_t				 header;
		int				 log_count;
		int				 i;

		/* first we need to get the flags & length of this chapter */
		header = packetBuffer[offset];
		log_count = header & RTP_MIDI_CJ_CHAPTER_A_MASK_LENGTH;

		/* count is encoded n+1 */
		log_count++;

		offset++;

		for ( i = 0; i < log_count; i++ ) {
			offset++;
			offset++;
		}

		return offset-start_offset;
	}

};

END_APPLEMIDI_NAMESPACE
